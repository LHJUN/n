title: Go Package
date: 2015-10-12 21:13:40
tags:
banner: /assets/gophercomplex1.jpg
---

Go 相较于 C++ 的一大进步即为具有良好的包管理系统. 在任何一个成熟的语言系统中包系统都是必不可少的. 本文将会对go的包系统进行详细的解释

<!-- more -->

### 定义

Go 的包使用关键字 `package` 进行定义, 后跟包名

```go
package main
```

golang 的 package 和其他语言的组织方式完全不同, go 的 package 超越了文件的概念. 即多个文件可以有相同的 package name. 因此多个文件中不能出现相同的全局变量和函数，一个例外是init函数；而同一个package的不同文件可以直接引用相互之间的数据。

包中的变量, 常量, 方法只有以大写字母作为首字符才算是外部可见内容, 否则只能在包内部使用.

每个包文件都可以定义 init 方法, 用于包初始化操作

```go
func init () {

}
```

一般情况下以代码文件所在的目录作为包名, 但并非强制. 同一个目录下至允许有一个包.

### 特殊包 main
main 包在 go 中是一个特殊的包, 必须有且只有一个, 因为程序的入口函数(main)在该包中, main 函数没有参数, 没有返回

```go
package main

func main () {

}
```


### 导入包
包导入使用 import 关键字, 后跟字符串形式的包名. Go 的标准库可以直接以名字导入,其实是去GOROOT下去加载该模块

```go
import "fmt"
```

go的package是以绝对路径GOPATH来寻址的，不要用相对路径来import(虽然也支持).

```go
import "a/b/c"     // 加载GOPATH/src/a/b/c
```

以通常惯例而言 import 路径的最后部分即为包名.

多个包引入可以分成多行, 也可以一次导入

```go
import (
    "fmt"
    "log"
)
```


几个特殊用法

```go
import _ “github.com/bitly/go-nsq” // 初始化某个包, 但不引入
import . "fmt"  // 调用包内容时可省略包名
import f "fmt"   // 别名导入
```

go 语言认可两个特殊的代码包名称 all, std. 前者代表了 GOPATH 中包含的所有工作区的所有代码包, 后者代表了 Go 语言标准库中的所有代码包

### 导入过程说明
程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。下图详细地解释了整个执行过程

![](/assets/go-package-import.jpg)

通过上面的介绍我们了解了import的时候其实是执行了该包里面的init函数，初始化了里面的变量，_操作只是说该包引入了，只初始化里面的init函数和一些变量，不能通过包名来调用其它的函数，这有什么用呢？往往这些init函数里面是注册自己包里面的引擎，让外部可以方便的使用，就很多实现database/sql的引起，在init函数里面都是调用了sql.Register(name string, driver driver.Driver)注册自己，然后外部就可以使用了。


### 工作区概念

go 是一门推崇软件工程理念的编程语言, 高度强调代码和项目的规范和统一. go 代码必须放在工作区中, 所谓的工作区就是一个特定的目录, 工作区中必须包含src, pkg, bin 三个目录.
工作区路径需要被加入到 GOPATH 环境变量中.

* src: 用于以代码包的形式组织, 保存源代码. 其中的代码包与src的子目录一一对应, 比如logging 包应位于logging目录下. main 包可以直接放在src下, 但通常不建议.
* pkg: 用于存放由 go install 命令编译安装后的代码包, 通常以 .a 结尾
* bin: 保存由 go install 命令完成之后生成的可执行文件

工作区可以有多个(都加入到 GOPATH), 通过 go get 命令获取的代码位于 GOPATH 的第一个工作区中, 通常情况建议不要把 GOROOT 放到 GOPATH 中, 并且添加两个工作区
到 GOPATH 中, 这样第一个工作区存放第三方库, 第二个则为真正的用户开发工作区.


### 依赖管理
在 Go 语言中，我们可以使用go get命令安装远程仓库中托管的代码，不同于 Ruby Gem、pypi 等集中式的包管理机制， Go 语言的包管理系统是去中心化的。简单来讲，go get命令支持任何一个位置托管的 Git 或 Mercurial 的仓库，无论是 Github 还是 Google Code 上的包，都可以通过这个命令安装

虽然 Go 语言本身已经提供了相当强大的包管理方式了，但是仍然有一些不足：

1. 不能很方便地隔离不同项目的环境
2. 不能很方便地控制某个依赖包的版本
3. 不能管理 Go 本身的版本

关于这些问题的解决办法可参看[这里](http://io-meter.com/2014/07/30/go%27s-package-management/)



### 参考

* [godoc](http://godoc.org/)
* [gopm.io](http://gopm.io/)
* [Go 语言本身提供的包管理机制](http://io-meter.com/2014/07/30/go%27s-package-management/)
