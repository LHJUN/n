{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/icarus/source/js/script.js","path":"js/script.js","modified":0},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.woff2","path":"font-awesome/fonts/fontawesome-webfont.woff2","modified":0},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.woff","path":"font-awesome/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.ttf","path":"font-awesome/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.svg","path":"font-awesome/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.eot","path":"font-awesome/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/icarus/source/font-awesome/fonts/FontAwesome.otf","path":"font-awesome/fonts/FontAwesome.otf","modified":0},{"_id":"themes/icarus/source/font-awesome/css/font-awesome.min.css","path":"font-awesome/css/font-awesome.min.css","modified":0},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/icarus/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/icarus/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/icarus/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/icarus/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/icarus/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/icarus/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/icarus/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":0},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":0},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":0},{"_id":"source/assets/nodejs-foundation.png","path":"assets/nodejs-foundation.png","modified":0},{"_id":"source/assets/nodejs-foundation-platinum.png","path":"assets/nodejs-foundation-platinum.png","modified":0},{"_id":"source/assets/nodejs-foundation-gold.png","path":"assets/nodejs-foundation-gold.png","modified":0},{"_id":"source/assets/nodejs-foundation-silver.png","path":"assets/nodejs-foundation-silver.png","modified":0},{"_id":"source/assets/gophercomplex1.jpg","path":"assets/gophercomplex1.jpg","modified":0},{"_id":"source/assets/go-package-import.jpg","path":"assets/go-package-import.jpg","modified":0}],"Cache":[{"_id":"source/_posts/about-node-foundation.md","shasum":"dc79928d7bde829beb6f6071a1d55a7e2193cc23","modified":1444655149000},{"_id":"source/_posts/about.md","shasum":"e01f71bea1f7be3994525dbc6162f2d9569d7dad","modified":1444472383000},{"_id":"source/_posts/application_deploy.md","shasum":"c2d44eed603d90e9f951439d672ffe8aff442890","modified":1444624387000},{"_id":"source/_posts/china_developer_work.md","shasum":"3574a15784bfaab81b95b30dc3396c5962913575","modified":1444624481000},{"_id":"source/_posts/coffeescript.md","shasum":"c61448f861b673155d4d8a8ade4f7f3c25be041b","modified":1444624473000},{"_id":"source/_posts/control_flow.md","shasum":"ad103b029c5b71768bf8df3abeab2d045db29059","modified":1444624469000},{"_id":"source/_posts/debug-test.md","shasum":"869fa8a89ac3183a847b4906825469254843d798","modified":1444624455000},{"_id":"source/_posts/dev-tools.md","shasum":"41738bdc3bd6c03b38d4d359acf030f0d87412e9","modified":1444624450000},{"_id":"source/_posts/enterprise_conclusion.md","shasum":"c3cfa0a0e2a9a8bdfb5b6463cb0d4ee2b2e2c801","modified":1444472517000},{"_id":"source/_posts/events.md","shasum":"f889683110874be1e88a9e1e2ad84fa977c04fec","modified":1444624439000},{"_id":"source/_posts/express-upgrade.md","shasum":"805b06c4f2079aeb854e40e7cda248a69dfdcc56","modified":1444624436000},{"_id":"source/_posts/generator.md","shasum":"5b651a9df853bb00f7ce3f0a52083026d10b41f8","modified":1444624432000},{"_id":"source/_posts/hello_world.md","shasum":"76ca4a4017e57ecf48eda97e6536d9bb5f45dcca","modified":1444624405000},{"_id":"source/_posts/module-machanism.md","shasum":"e32b94f6a9c6494798a5f2f0856ba51098b85b9d","modified":1444624645000},{"_id":"source/_posts/n_blog_platform.md","shasum":"254bac804b71d63a7ddf7d745875d800f7bc90b8","modified":1444624634000},{"_id":"source/_posts/nko.md","shasum":"0a669db29cdaf951ea5a789cdf9447bc234b81d1","modified":1444624629000},{"_id":"source/_posts/node-books.md","shasum":"e26c3ba7fae5d12affc6f5fb8519dde3507aa581","modified":1444624625000},{"_id":"source/_posts/node-conf.md","shasum":"5568013bfba77c1cd2f516b32efd89e472a639b6","modified":1444624618000},{"_id":"source/_posts/node-yingyong-changjing.md","shasum":"b1d3c270b1384ceaddab9caadf0ba97e5eea1dd5","modified":1444624613000},{"_id":"source/_posts/node012-upgrade.md","shasum":"09db8ffbf3eaa6eb581bf0cc6222ce9c9481240f","modified":1444561709000},{"_id":"source/_posts/nodejs-gaoxingneng.md","shasum":"3848c106104f995f9405477c93649405e466007b","modified":1444624605000},{"_id":"source/_posts/nodejs-native-modules.md","shasum":"d51d71411b668fb4502c4c3ca0cb6b4b73f29f5b","modified":1444624594000},{"_id":"source/_posts/nodejs.md","shasum":"d55ccc8abbb5b6c7ba7afeb624cb185ef45f6386","modified":1444472383000},{"_id":"source/_posts/nodejs_install.md","shasum":"cfe07716bed26c8140299d485953eec018a44a33","modified":1444624578000},{"_id":"source/_posts/performance-monitor.md","shasum":"ee1b2af8476ac1cac6d18bd479c0da8a46b624b9","modified":1444624571000},{"_id":"source/_posts/repl.md","shasum":"024075c519e64974ee8ff577408630b440f74d85","modified":1444624567000},{"_id":"source/_posts/upgrade-node-npm.md","shasum":"469b07c992af5c66e6d9abf28ede51852548405b","modified":1444624563000},{"_id":"source/_posts/use-in-production.md","shasum":"51e9ecda4c353ffbe9922ed9c11d54e480f76b98","modified":1444472383000},{"_id":"source/_posts/useful-cmd-module.md","shasum":"c747a944af6944e95fcff48ed60cb9cf67a3e3fc","modified":1444624542000},{"_id":"source/tags/index.md","shasum":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1444531205000},{"_id":"themes/icarus/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1444471816000},{"_id":"themes/icarus/LICENSE","shasum":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1444471816000},{"_id":"themes/icarus/README.md","shasum":"b2fd6c4a5fb5f0094a66a7a4a34a1e4be0b808c0","modified":1444471816000},{"_id":"themes/icarus/_config.yml","shasum":"7f369d64b27fc68d2fb282a691b5b05894a9da29","modified":1445133033000},{"_id":"themes/icarus/_config.yml.example","shasum":"c3a71bfe58040583381f412e5f96eaa796ec1b19","modified":1444471816000},{"_id":"themes/icarus/_config.yml.site.example","shasum":"2f88e9c41038c5053c0acca9dfebf430f78fa4fa","modified":1444471816000},{"_id":"themes/icarus/_source/categories/index.md","shasum":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1444471816000},{"_id":"themes/icarus/_source/tags/index.md","shasum":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1444471816000},{"_id":"themes/icarus/languages/en.yml","shasum":"f295d0d92b5a583c193b4bb92ea1a9834084f9b4","modified":1444471816000},{"_id":"themes/icarus/languages/es.yml","shasum":"3ef1e80c4adea30ff72dbc91fb318f0ad8566775","modified":1444471816000},{"_id":"themes/icarus/languages/id.yml","shasum":"3db9fd53c1956b6821f813c6c89209825b718e22","modified":1444471816000},{"_id":"themes/icarus/languages/ja.yml","shasum":"e731d3c484ee5c7f17f97489fcd6a36edba37946","modified":1444471816000},{"_id":"themes/icarus/languages/ru.yml","shasum":"8ae493cbfb18843f2770f8f35e21cb783f3f9cf5","modified":1444471816000},{"_id":"themes/icarus/languages/zh-CN.yml","shasum":"0b0e433afa0cc4c3282bcd7ff56cd7204f3db361","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/after-footer.ejs","shasum":"9fd77b257cdd0276ce62dcf1ab41cb1f51fb463c","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/archive-post.ejs","shasum":"4be85893e8fb09be7e411001d5a14c05b6da475a","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/archive.ejs","shasum":"8a65b701f1af5cd4d98ba48591b4a10c768ac66f","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/article.ejs","shasum":"5bbe48b3a50a3f1fa7aeb36f40ef8441f5283def","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/cdn_after_footer.ejs","shasum":"0323d1f048c0288b40bb8d918c65d83a1e90a895","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/cdn_head.ejs","shasum":"6287ea0901899a4cdd3fd2908e7a1ed683e90881","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/footer.ejs","shasum":"f471f17e2524bfcb37d43d9fc85b5fc247ad08b1","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/google_site_verification.ejs","shasum":"63b388e87d0a2d0cbddd60a329dc951edd444d48","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/head.ejs","shasum":"001b72f03dd3f6c798c76026fd153c9ff3f44888","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/header.ejs","shasum":"866431639ed1584b8c9a7deda13c5ec71cb48e5d","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/post/banner.ejs","shasum":"d67a43264f457c4f914a1e636ebc3e2eaac6fb71","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/post/category.ejs","shasum":"461fa17b3fab1067a7ff8d03130b60403515cf02","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/post/date.ejs","shasum":"e0e2f5016aa02a6ac7d0b9bca463129b6b86c5f3","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/post/nav.ejs","shasum":"e4dc35cbdf1c33996cea79f19e2eda74228ddd09","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/post/thumbnail.ejs","shasum":"67e249af07eb36088fc37400a58433eb0ff50121","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/profile.ejs","shasum":"7d6f56890b852f5fd619e0e31e23c196b13e74bf","modified":1444471816000},{"_id":"themes/icarus/layout/_partial/sidebar.ejs","shasum":"35fbf9cd6d76c49c4f9329bc6e8f9c88703988ec","modified":1444471816000},{"_id":"themes/icarus/layout/_widget/archive.ejs","shasum":"96321559b5c4e302af3012404537fb95c3a7f3b8","modified":1444471816000},{"_id":"themes/icarus/layout/_widget/category.ejs","shasum":"5eb356275709ed2cce3bd13cb95743b7ecd4dab1","modified":1444471816000},{"_id":"themes/icarus/layout/_widget/links.ejs","shasum":"5a217756c4175cc74d8b1734883d1c3d6d1c8d7c","modified":1444471816000},{"_id":"themes/icarus/layout/_widget/recent_posts.ejs","shasum":"942a8ea2ff6284217b14664879cf461515f0e36f","modified":1444471816000},{"_id":"themes/icarus/layout/_widget/tag.ejs","shasum":"9f16e1d97a6908d80aa214a373025cbd03ad7e14","modified":1444471816000},{"_id":"themes/icarus/layout/_widget/tagcloud.ejs","shasum":"bb6d04024fdea842be461e27086c2c138d15de92","modified":1444471816000},{"_id":"themes/icarus/layout/archive.ejs","shasum":"4479c33517aa70f2714ee820775ff8307a0dd115","modified":1444471816000},{"_id":"themes/icarus/layout/categories.ejs","shasum":"db9c4981c8d87e8b08e595a10051f3e13c857cdf","modified":1444471816000},{"_id":"themes/icarus/layout/category.ejs","shasum":"cd17981f9cac718731880148cb17de60d148a75c","modified":1444471816000},{"_id":"themes/icarus/layout/index.ejs","shasum":"505555df272ac4dd23e5eae3acb857a457e421b4","modified":1444471816000},{"_id":"themes/icarus/layout/layout.ejs","shasum":"fc6e16387a9b4bc9532b01380ed669372c1df1ad","modified":1444471816000},{"_id":"themes/icarus/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1444471816000},{"_id":"themes/icarus/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1444471816000},{"_id":"themes/icarus/layout/tag.ejs","shasum":"bcde8c7ce7e21683ca2cba7fcc21ac43c817a9a4","modified":1444471816000},{"_id":"themes/icarus/layout/tags.ejs","shasum":"cf485e9053f96d69a1e0ce0f8a55c3aa33ebde03","modified":1444471816000},{"_id":"themes/icarus/package.json","shasum":"a4368eebf2ed07c0aaf9b02d21736da2cef611d4","modified":1444471816000},{"_id":"themes/icarus/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1444471816000},{"_id":"themes/icarus/source/css/_extend.styl","shasum":"1dad1d157a4d3c4186b27dcfb4549facaebce927","modified":1444471816000},{"_id":"themes/icarus/source/css/_partial/archive.styl","shasum":"7e80a60a5fca12be154d3ad77ea5230357412670","modified":1444471816000},{"_id":"themes/icarus/source/css/_partial/article.styl","shasum":"95a991e7340d02cb9a55e89f8818de05b8bb37df","modified":1444471816000},{"_id":"themes/icarus/source/css/_partial/comment.styl","shasum":"6846fc40b8cad267b92ceafb1be35c03fde6e494","modified":1444471816000},{"_id":"themes/icarus/source/css/_partial/footer.styl","shasum":"a73e33a019b46c46080a66f7ce8e112e8bb32075","modified":1444471816000},{"_id":"themes/icarus/source/css/_partial/header.styl","shasum":"73c3f7176d2e838ef767951fc8215689e4297e45","modified":1444471816000},{"_id":"themes/icarus/source/css/_partial/highlight.styl","shasum":"19c0c1d8d0287808f8eac8e9c9e6deb43efcfc9e","modified":1444471816000},{"_id":"themes/icarus/source/css/_partial/profile.styl","shasum":"1917670cd1f89260fbb81c8bcc01eb3c54584597","modified":1444471816000},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","shasum":"6dc9095787061c7a3786a9d464b451a0c4ae7475","modified":1444471816000},{"_id":"themes/icarus/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1444471816000},{"_id":"themes/icarus/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1444471816000},{"_id":"themes/icarus/source/css/_variables.styl","shasum":"ffae2b43c0fb48b3a3ca0e2c0cbf4a089356094d","modified":1444471816000},{"_id":"themes/icarus/source/css/images/avatar.png","shasum":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1444471816000},{"_id":"themes/icarus/source/css/images/logo.png","shasum":"e606a0584f98268b2fe92303f3254520862ef659","modified":1444471816000},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","shasum":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1444471816000},{"_id":"themes/icarus/source/css/style.styl","shasum":"62add563ec23f75fa7bde0395778bf81cc821d4e","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.css","shasum":"9673e160d32c4811bb7e930ba1e20c36b2997fe1","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1444471816000},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1444471816000},{"_id":"themes/icarus/source/font-awesome/css/font-awesome.min.css","shasum":"8c15c6bd82c71e9ef1bb11cf24e502fe07518ac5","modified":1444471816000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.eot","shasum":"3e63fc9b3de4580f1f3bec0631436f755b80f167","modified":1444471816000},{"_id":"themes/icarus/source/js/script.js","shasum":"5a9f81308b775d3b5a5e737d1836f61d42661691","modified":1444471816000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"1075231650f579955905bb2f6527148a8e2b4b16","modified":1444471816000},{"_id":"themes/icarus/source/font-awesome/fonts/FontAwesome.otf","shasum":"cde9eb92c8a3ba23d648f76ea3931511f30813f4","modified":1444471816000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"9088143b19979779b2116cef38b661f72d982e19","modified":1444471816000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.woff","shasum":"56ce13e71c2150d81bc972940584915181bd6081","modified":1444471816000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.svg","shasum":"26bb1c5ef100a1cd71923f1d5dc29fc797ef4639","modified":1444471816000},{"_id":"source/assets/nodejs-foundation.png","shasum":"aa044aba6e3195d44bc6d532e7478f15269ad14e","modified":1444562125000},{"_id":"source/assets/nodejs-foundation-platinum.png","shasum":"68d3d2d3621e6bda455d8452cb9ccc1995bb0586","modified":1444653880000},{"_id":"source/assets/nodejs-foundation-gold.png","shasum":"304290f1f65feb6101a87dd553bc4ab37d26248f","modified":1444653894000},{"_id":"source/assets/nodejs-foundation-silver.png","shasum":"0ea1639c47db9f8de76a544715bd8bfd4c4e9ad6","modified":1444653902000},{"_id":"source/assets/gophercomplex1.jpg","shasum":"49f05773c58181037ef71f1b131ca322bcc870f3","modified":1444655880000},{"_id":"source/about/index.md","shasum":"81838caa8f96f3acbd6557a1ea30c956192bb602","modified":1444656137000},{"_id":"source/_posts/go-package.md","shasum":"ee23be516747f95ebc9d78a3ab9835ff9d435e23","modified":1445132556000},{"_id":"source/assets/go-package-import.jpg","shasum":"62e0387623c037fe883cb43fcf43e631794e5d1e","modified":1444658906000},{"_id":"public/assets/gophercomplex1.jpg","modified":1445133114778,"shasum":"49f05773c58181037ef71f1b131ca322bcc870f3"},{"_id":"public/assets/go-package-import.jpg","modified":1445133114786,"shasum":"62e0387623c037fe883cb43fcf43e631794e5d1e"},{"_id":"public/tags/index.html","modified":1445133114880,"shasum":"ff5972fea865ea7a31e754148249dee714ba1677"},{"_id":"public/about/index.html","modified":1445133114926,"shasum":"e490715edec8c45d15cbfa8416ee8b2e4788f172"},{"_id":"public/2015/10/12/go-package/index.html","modified":1445133114980,"shasum":"9c6afedfff7f6814624a457104316fb1bed3dc6e"},{"_id":"public/2015/10/11/about-node-foundation/index.html","modified":1445133115038,"shasum":"441fed790fdb84c1f1cd8dff03a5186fd3edb98d"},{"_id":"public/2014/04/08/node012-upgrade/index.html","modified":1445133115081,"shasum":"e3b9f1915f650aa263f957a64ed13a851a01d272"},{"_id":"public/2014/03/25/upgrade-node-npm/index.html","modified":1445133115124,"shasum":"ea86a0365c77d18999760ef538b7d8a8a0cb6e69"},{"_id":"public/2014/02/25/express-upgrade/index.html","modified":1445133115162,"shasum":"ff1d35819102002f6edb9a23c7090e7a5d135887"},{"_id":"public/2014/01/28/enterprise_conclusion/index.html","modified":1445133115217,"shasum":"5371cded4e7fbdc66d827c9bda226e718aa0f12d"},{"_id":"public/2014/01/27/performance-monitor/index.html","modified":1445133115257,"shasum":"cf6aea6b9dca2b31188ba576c98fc0248ad4f7e6"},{"_id":"public/2014/01/25/application_deploy/index.html","modified":1445133115306,"shasum":"114e3ef2a9b8b2b0327c6fc1f6599bf0567bc23a"},{"_id":"public/2014/01/15/debug-test/index.html","modified":1445133115345,"shasum":"a142aa8e24144efdf08d44e256e3d43cc9922f7b"},{"_id":"public/2014/01/10/nodejs-gaoxingneng/index.html","modified":1445133115400,"shasum":"314127e1c64dff547ea5cf1ed8dda1335ecb8966"},{"_id":"public/2014/01/06/node-yingyong-changjing/index.html","modified":1445133115440,"shasum":"ca0ee00fb35e2719d1d43a2c382d81f3d81ac06c"},{"_id":"public/2014/01/02/generator/index.html","modified":1445133115491,"shasum":"2080ecdf7fc748e8c97fb9e281f6e0e140c6575f"},{"_id":"public/2013/11/21/use-in-production/index.html","modified":1445133115527,"shasum":"09d5805ffafb4263723b98bf3a8d7370db496f7a"},{"_id":"public/2013/11/19/node-conf/index.html","modified":1445133115565,"shasum":"abd12c48733dcb57f5e33bbde6837998aeb16f27"},{"_id":"public/2013/11/19/nko/index.html","modified":1445133115622,"shasum":"6e31fd170e667360639084944eaff9eb494a829e"},{"_id":"public/2013/11/18/node-books/index.html","modified":1445133115663,"shasum":"71d7e46def7ee08820150b73e01b75c1f4d7b9d4"},{"_id":"public/2013/11/13/control_flow/index.html","modified":1445133115700,"shasum":"53eef833e2f923f2043d799b989363c4043b5b2e"},{"_id":"public/2013/11/08/events/index.html","modified":1445133115737,"shasum":"8927fa0aaa6e57a9a773d1ae2df0c06030e6597e"},{"_id":"public/2013/10/25/module-machanism/index.html","modified":1445133115794,"shasum":"7fa1ba4c29424193067a764013b01f6be9f67294"},{"_id":"public/2013/10/18/dev-tools/index.html","modified":1445133115833,"shasum":"edcff8cda549611ecd0f8c86cb82a39239646aaf"},{"_id":"public/2013/10/09/coffeescript/index.html","modified":1445133115878,"shasum":"382a26de561949f9ef4608e17198908a42404575"},{"_id":"public/2013/10/09/useful-cmd-module/index.html","modified":1445133115918,"shasum":"ca31f238dafba61697e22b433345acc295565f92"},{"_id":"public/2013/09/28/n_blog_platform/index.html","modified":1445133115972,"shasum":"879f200f20c1bbc123e32944d19af723b2d0561a"},{"_id":"public/2013/09/27/china_developer_work/index.html","modified":1445133116012,"shasum":"3ee896707bfdf64ad58e27a8d835fedfde4dafe3"},{"_id":"public/2013/09/23/repl/index.html","modified":1445133116050,"shasum":"7cf6f0007fedfac75e1e6896f497ebd098457633"},{"_id":"public/2013/09/22/hello_world/index.html","modified":1445133116092,"shasum":"955b329b9b9c32f5026c1a34ed9cd54b7de9e870"},{"_id":"public/2013/09/21/nodejs_install/index.html","modified":1445133116144,"shasum":"5c18916729f67d4f1533357f54832807a9154ca0"},{"_id":"public/2013/09/17/nodejs-native-modules/index.html","modified":1445133116187,"shasum":"803b4a64066a617c7775e21f08839bf4603aa2be"},{"_id":"public/2013/09/11/about/index.html","modified":1445133116225,"shasum":"55e3462d469b32395f9408513921f3d5e375ef1d"},{"_id":"public/2013/09/11/nodejs/index.html","modified":1445133116268,"shasum":"6fb80b43b4b2cd56bcd4d514397d4f3e27d48c7d"},{"_id":"public/archives/index.html","modified":1445133116364,"shasum":"e7a360bea3a981bf71f724c465400e72a14509ae"},{"_id":"public/archives/page/2/index.html","modified":1445133116437,"shasum":"afc137a300df7a57e54a9a0c75adae5a536a4b3c"},{"_id":"public/archives/page/3/index.html","modified":1445133116548,"shasum":"ffc67460a9e769b8e632cfe28044bf1c670aaf75"},{"_id":"public/archives/page/4/index.html","modified":1445133116638,"shasum":"8c49e8156d15184c750e2e27d93d24410e3e299d"},{"_id":"public/archives/page/5/index.html","modified":1445133116767,"shasum":"6f30a8e007e5a5737d32945e58bc8a30ef636171"},{"_id":"public/archives/2013/index.html","modified":1445133116888,"shasum":"8150926138984a66093090a1299d825d317229b3"},{"_id":"public/archives/2013/page/2/index.html","modified":1445133116904,"shasum":"3bab040f6b4f1d34db7fac3830300f9e58b63bbf"},{"_id":"public/archives/2013/page/3/index.html","modified":1445133116916,"shasum":"28e7d8270a4b2ba76015b42fe21688dd9a7621d3"},{"_id":"public/archives/2013/09/index.html","modified":1445133116931,"shasum":"dd1c5d249596eeff20c66133b0602fc02c2746dd"},{"_id":"public/archives/2013/09/page/2/index.html","modified":1445133116939,"shasum":"d853c847b14ef34ae74525973ace3ffe2ee573bb"},{"_id":"public/archives/2013/10/index.html","modified":1445133116950,"shasum":"9784168c31294eb99ad20055509794d41ac4d282"},{"_id":"public/archives/2013/11/index.html","modified":1445133116964,"shasum":"7b073a20dd943af5e16d8c3771a761050eda7163"},{"_id":"public/archives/2014/index.html","modified":1445133116978,"shasum":"15232ed57034d110325168a03c96ab03378db964"},{"_id":"public/archives/2014/page/2/index.html","modified":1445133116986,"shasum":"2aff6e6a606b0bc6bd3041315676747a74ee3346"},{"_id":"public/archives/2014/01/index.html","modified":1445133117000,"shasum":"166bc327db6b7d8f31d043235e008f541e1392c0"},{"_id":"public/archives/2014/01/page/2/index.html","modified":1445133117007,"shasum":"e6fc347ecc4f3f7f66f9d0ae21d2eb2897f4c3e7"},{"_id":"public/archives/2014/02/index.html","modified":1445133117017,"shasum":"001a5d93046114ead5496250bae038c1fed73c11"},{"_id":"public/archives/2014/03/index.html","modified":1445133117023,"shasum":"5c4e975723720cc215c404185961e02fbb954535"},{"_id":"public/archives/2014/04/index.html","modified":1445133117028,"shasum":"d893cfd881ed01adf18faed147db1356a99a191b"},{"_id":"public/archives/2015/index.html","modified":1445133117035,"shasum":"8e0900f4fafbf4047b106febe7a97c0b6076999f"},{"_id":"public/archives/2015/10/index.html","modified":1445133117041,"shasum":"f3805b72e399cc2320799662f4c535c1bc57b844"},{"_id":"public/index.html","modified":1445133117062,"shasum":"b1effb3894de2d695fcd6df7242a4c80e7c35c5c"},{"_id":"public/page/2/index.html","modified":1445133117076,"shasum":"4347045d6f9ecfaee10c109c401626cfb4cff35d"},{"_id":"public/page/3/index.html","modified":1445133117090,"shasum":"ca90d588469bde2a060c8f34c5d01fc83be4d6d3"},{"_id":"public/page/4/index.html","modified":1445133117104,"shasum":"056a49321507b2bca2b36e37e59aa328c424dd0d"},{"_id":"public/page/5/index.html","modified":1445133117122,"shasum":"9b2d423e24e41f17cbeac50af4646bf1d0b2c7fc"},{"_id":"public/tags/应用/index.html","modified":1445133117128,"shasum":"65bf9ccb1a7a86f32f3daf9ec10874133707aeff"},{"_id":"public/tags/REPL/index.html","modified":1445133117133,"shasum":"8a7e919c91fc567eee1327c0d43217f8fb4f7f24"},{"_id":"public/tags/安装/index.html","modified":1445133117142,"shasum":"39167792bf08cd94d544fc18307cf97903d395ba"},{"_id":"public/tags/Intro/index.html","modified":1445133117147,"shasum":"d49b8fe7f74a0e982fe4d2c1122bc4613e6e948b"},{"_id":"public/tags/Native-Module/index.html","modified":1445133117154,"shasum":"083c432407e56777da5dfded4f805a8baec6fd7b"},{"_id":"public/tags/应用场景/index.html","modified":1445133117160,"shasum":"ec16dabae0e1b2a618b29ad5ec7b7014ddbf9254"},{"_id":"public/tags/conference/index.html","modified":1445133117166,"shasum":"718cf49b073292d327211eab6331311d96822e5b"},{"_id":"public/tags/Competition/index.html","modified":1445133117171,"shasum":"e0ba31ec567abb36a8d72598d73d9d0cf4e22ea8"},{"_id":"public/tags/blog-cms/index.html","modified":1445133117177,"shasum":"b4b17333d1d789b5fc60e8a88a43d2b7bd024850"},{"_id":"public/tags/Module/index.html","modified":1445133117183,"shasum":"3b823dc9b08130675f28dc2286ebc86c8b1d44d2"},{"_id":"public/tags/HelloWorld/index.html","modified":1445133117188,"shasum":"47f7b3141289392e43fe93fc4c73028afb6fb1e7"},{"_id":"public/tags/ES6-异步流程/index.html","modified":1445133117193,"shasum":"b11c421b0d81bb58adbb5a05b9a01c5b3384f076"},{"_id":"public/tags/Express-upgrade/index.html","modified":1445133117198,"shasum":"966f7a85358145055c21908227b06bcc3f2f041d"},{"_id":"public/tags/工具/index.html","modified":1445133117203,"shasum":"f311b1c0efae45893aa401676b373fe255aa0629"},{"_id":"public/tags/coffeescript/index.html","modified":1445133117209,"shasum":"50349e9da8c46bd5c1962f15f79cde45aa400b0f"},{"_id":"public/tags/国内/index.html","modified":1445133117214,"shasum":"dcc332cdbfb89adc7655cfdbff6798deb87867f2"},{"_id":"public/tags/说明/index.html","modified":1445133117222,"shasum":"e73d3b0baa1ac5d4e89a34a6dcf9068c18323461"}],"Category":[],"Data":[],"Page":[{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2015-10-11T02:40:05.000Z","updated":"2015-10-11T02:40:05.000Z","path":"tags/index.html","comments":1,"_id":"cifmerdzl0001vs1m2bpic1vc"},{"title":"关于","date":"2015-10-12T13:20:58.000Z","_content":"\nN 是一个技术博客, 最初主要介绍 Node.js 相关的技术问题, 后扩展到 Go.\n","source":"about/index.md","raw":"title: 关于\ndate: 2015-10-12 21:20:58\n---\n\nN 是一个技术博客, 最初主要介绍 Node.js 相关的技术问题, 后扩展到 Go.\n","updated":"2015-10-12T13:22:17.000Z","path":"about/index.html","_id":"cifnyx16d00022m1m4xlfsedv","comments":1,"layout":"page"}],"Post":[{"title":"Node 基金会那些事","date":"2015-10-11T11:08:15.000Z","banner":"/assets/nodejs-foundation.png","_content":"最近 RedHat 刚刚加入了 Node.js 基金会, 这对 Node 来说又是一次不小的胜利. Node.js 基金会成立也有一段时间了, 并且刚刚完成了 Node 和 iojs 的合并工作, 今天我们就来聊聊这个基金会.\n\n<!-- more -->\n\n### 简介\n\n[Node 基金会](https://nodejs.org/en/foundation/)是 Linux 基金会的 collaborative project, 也是在后者的帮助下建立起来的. 众所周知 Linux 基金会是一个非盈利性的联盟，其目的在于协调和推动Linux系统的发展，以及宣传、保护和规范Linux. 该组织具有多年丰富的开源项目运营经验. \n\n>The Node.js Foundation's mission is to enable widespread adoption and help accelerate development of Node.js and other related modules through an open governance model that encourages participation, technical contribution, and a framework for long term stewardship by an ecosystem invested in Node.js' success.\n\n以上为该基金会的使命宗旨, 大意是以一种开放的管理方式促进 Node 的持续开发和应用.\n\n\n### 历史\n\nNode 基金会成立于 2015 年 2 月份, Joyent 宣布同 linux 基金会一道创立, 并将项目移交给该基金会, 并自动成为基金会的一名平台级成员. 基金会成立乃是无奈之举, node 0.12 的长期难产, 导致社区对Joyent的管理方式超级不满, 愤而创建了有名的 io.js 分支, 并迅速获得了大批支持者. 为避免社区长期分裂 Joyent 退步选择通过基金会的形式继续推动 Node 项目发展. 经过协商 io.js 在 5.18 号同意合并到 node 基金会下, 最终项目还保持Node.js 不变, 但项目将以 io.js 的 codebase 为主体. 代码合并工作随后展开. 与此同时基金会的创建工作也在同步进行. 具体的时间线可以[参看这里](https://nodejs.org/en/foundation/#timeline)\n\n代码合并工作在 9.14 号完成, 并发布了版本 4.0, 同时还决定在 12.8-9 号在波特兰举办官方的开发者大会 [Node.js interactive](http://events.linuxfoundation.org/events/node-interactive)\n\n### 成员\nNode.js 基金会公司成员根据其所交年费, 及行使权力不同分为: 白金, 金牌, 银牌三种会员. 其中 Paypal, Microsoft, IBM, RedHat, Intel 等均为白金会员\n\n![Platinum](/assets/nodejs-foundation-platinum.png)\n![Gold](/assets/nodejs-foundation-gold.png)\n![Silver](/assets/nodejs-foundation-silver.png)\n\n技术委员会成员主要由核心开发者构成, 他们负责[管理](https://github.com/nodejs/node/blob/master/GOVERNANCE.md)整个项目, 当前委员会成员有:\n\n* Alexis Campailla (orangemocha)\n* Ben Noordhuis (bnoordhuis)\n* Bert Belder (piscisaureus)\n* Brian White (mscdex)\n* Chris Dickinson (chrisdickinson)\n* Colin Ihrig (cjihrig)\n* Fedor Indutny (indutny)\n* James M Snell (jasnell)\n* Jeremiah Senkpiel (Fishrock123)\n* Julien Gilli (misterdjules)\n* Rod Vagg (rvagg)\n* Shigeki Ohtsu (shigeki)\n* Trevor Norris (trevnorris)\n\n\n### 参考\n\n* [Node 基金会](https://nodejs.org/en/foundation/)\n* [oschina](http://www.oschina.net/news/59615/node-js-foundation)\n* [Infoq](http://www.infoq.com/cn/news/2015/05/nodejs-iojs/)\n* [Node.js基金会成立，Joyent交出领导权](http://www.infoq.com/cn/news/2015/02/nodejs-foundation-establish)","source":"_posts/about-node-foundation.md","raw":"title: Node 基金会那些事\ndate: 2015-10-11 19:08:15\ntags:\nbanner: /assets/nodejs-foundation.png\n---\n最近 RedHat 刚刚加入了 Node.js 基金会, 这对 Node 来说又是一次不小的胜利. Node.js 基金会成立也有一段时间了, 并且刚刚完成了 Node 和 iojs 的合并工作, 今天我们就来聊聊这个基金会.\n\n<!-- more -->\n\n### 简介\n\n[Node 基金会](https://nodejs.org/en/foundation/)是 Linux 基金会的 collaborative project, 也是在后者的帮助下建立起来的. 众所周知 Linux 基金会是一个非盈利性的联盟，其目的在于协调和推动Linux系统的发展，以及宣传、保护和规范Linux. 该组织具有多年丰富的开源项目运营经验. \n\n>The Node.js Foundation's mission is to enable widespread adoption and help accelerate development of Node.js and other related modules through an open governance model that encourages participation, technical contribution, and a framework for long term stewardship by an ecosystem invested in Node.js' success.\n\n以上为该基金会的使命宗旨, 大意是以一种开放的管理方式促进 Node 的持续开发和应用.\n\n\n### 历史\n\nNode 基金会成立于 2015 年 2 月份, Joyent 宣布同 linux 基金会一道创立, 并将项目移交给该基金会, 并自动成为基金会的一名平台级成员. 基金会成立乃是无奈之举, node 0.12 的长期难产, 导致社区对Joyent的管理方式超级不满, 愤而创建了有名的 io.js 分支, 并迅速获得了大批支持者. 为避免社区长期分裂 Joyent 退步选择通过基金会的形式继续推动 Node 项目发展. 经过协商 io.js 在 5.18 号同意合并到 node 基金会下, 最终项目还保持Node.js 不变, 但项目将以 io.js 的 codebase 为主体. 代码合并工作随后展开. 与此同时基金会的创建工作也在同步进行. 具体的时间线可以[参看这里](https://nodejs.org/en/foundation/#timeline)\n\n代码合并工作在 9.14 号完成, 并发布了版本 4.0, 同时还决定在 12.8-9 号在波特兰举办官方的开发者大会 [Node.js interactive](http://events.linuxfoundation.org/events/node-interactive)\n\n### 成员\nNode.js 基金会公司成员根据其所交年费, 及行使权力不同分为: 白金, 金牌, 银牌三种会员. 其中 Paypal, Microsoft, IBM, RedHat, Intel 等均为白金会员\n\n![Platinum](/assets/nodejs-foundation-platinum.png)\n![Gold](/assets/nodejs-foundation-gold.png)\n![Silver](/assets/nodejs-foundation-silver.png)\n\n技术委员会成员主要由核心开发者构成, 他们负责[管理](https://github.com/nodejs/node/blob/master/GOVERNANCE.md)整个项目, 当前委员会成员有:\n\n* Alexis Campailla (orangemocha)\n* Ben Noordhuis (bnoordhuis)\n* Bert Belder (piscisaureus)\n* Brian White (mscdex)\n* Chris Dickinson (chrisdickinson)\n* Colin Ihrig (cjihrig)\n* Fedor Indutny (indutny)\n* James M Snell (jasnell)\n* Jeremiah Senkpiel (Fishrock123)\n* Julien Gilli (misterdjules)\n* Rod Vagg (rvagg)\n* Shigeki Ohtsu (shigeki)\n* Trevor Norris (trevnorris)\n\n\n### 参考\n\n* [Node 基金会](https://nodejs.org/en/foundation/)\n* [oschina](http://www.oschina.net/news/59615/node-js-foundation)\n* [Infoq](http://www.infoq.com/cn/news/2015/05/nodejs-iojs/)\n* [Node.js基金会成立，Joyent交出领导权](http://www.infoq.com/cn/news/2015/02/nodejs-foundation-establish)","slug":"about-node-foundation","published":1,"updated":"2015-10-12T13:05:49.000Z","_id":"cifmerdz40000vs1mg9tx5r8t","comments":1,"layout":"post","photos":[],"link":""},{"title":"Useful CMD Module","date":"2013-10-09T01:38:47.000Z","_content":"\nNode催生了许多有用的终端命令工具, 能帮助我们快速的开发和工作, 例如进程守护, 文件变化监视, 静态server等. 本文会列举一些常用的工具.\n\n<!-- more -->\n\n\n## file watcher\n监视文件变化情况, 自动重新载入文件\n\n* [supervisor](https://github.com/isaacs/node-supervisor)\n* [nodemon](http://remy.github.io/nodemon/)\n* [node-dev](https://github.com/fgnass/node-dev)\n\n## static server\n静态服务器\n\n* [serve](https://github.com/visionmedia/serve)\n* [harp](http://harpjs.com/)\n\n## 进程守护\n\n* [forever](https://github.com/nodejitsu/forever)\n* [pm2](https://github.com/Unitech/pm2)\n\n## 自动化工具\n\n* [grunt](http://gruntjs.com/)\n\n## 前端包管理工具\n\n* [bower](http://bower.io/)\n* [jam](http://jamjs.org/)\n* [component](http://component.io/)\n\n## workflow\n\n* [yeoman](http://yeoman.io/)\n\n\n\n以上为目前发现的相关Module, 该文章会持续更新如果有发现其他好用东西, 或由自己见解可通过邮箱联系.","source":"_posts/useful-cmd-module.md","raw":"title: Useful CMD Module\ndate: 2013-10-09 09:38:47\ntags:\n---\n\nNode催生了许多有用的终端命令工具, 能帮助我们快速的开发和工作, 例如进程守护, 文件变化监视, 静态server等. 本文会列举一些常用的工具.\n\n<!-- more -->\n\n\n## file watcher\n监视文件变化情况, 自动重新载入文件\n\n* [supervisor](https://github.com/isaacs/node-supervisor)\n* [nodemon](http://remy.github.io/nodemon/)\n* [node-dev](https://github.com/fgnass/node-dev)\n\n## static server\n静态服务器\n\n* [serve](https://github.com/visionmedia/serve)\n* [harp](http://harpjs.com/)\n\n## 进程守护\n\n* [forever](https://github.com/nodejitsu/forever)\n* [pm2](https://github.com/Unitech/pm2)\n\n## 自动化工具\n\n* [grunt](http://gruntjs.com/)\n\n## 前端包管理工具\n\n* [bower](http://bower.io/)\n* [jam](http://jamjs.org/)\n* [component](http://component.io/)\n\n## workflow\n\n* [yeoman](http://yeoman.io/)\n\n\n\n以上为目前发现的相关Module, 该文章会持续更新如果有发现其他好用东西, 或由自己见解可通过邮箱联系.","slug":"useful-cmd-module","published":1,"updated":"2015-10-12T04:35:42.000Z","_id":"cifmere000005vs1mfp4x4eit","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js企业开发","date":"2013-11-21T03:30:14.000Z","_content":"从Node.js最初版本发布到现在已经走过了四年多的时间. 从最初的Web服务器, 到发展成为全面的后台环境, NPM从几百个Module到5万+, 且还在不断飞速增长, 从最初的JS开发者到现在的专门Node开发者以及众多的开发者大会和比赛. 从最初的Demo开发到LinkedIn, Paypal, groupon等大公司采用. Node已经渐渐成熟, 马上0.12版本就会到来, 届时Node API的将会确定下来. 这些都为Node在企业生产环境中大规模应用准备好了条件. N博客将会介绍一系列Node.js正式环境应用的相关内容.\n\n* Node.js适合应用场景\n* 如何开发高效, 健壮, 安全, 可扩展的Node应用\n* 项目架构, 文档, 私有NPM\n* Node项目调试, 测试, 异常处理, 容错\n* Node应用部署, 进程守护, cluster, 日志, 报警, nginx\n* Node服务监控, 内存泄露检测\n* 其他: benchmark\n\n#### 参考资料\n\n* [构建Node.js应用的10个重要的方面](http://tech.it168.com/a2013/0308/1460/000001460366.shtml)\n* [Towards 100% Uptime with Node.js](http://sandinmyjoints.github.io/towards-100-pct-uptime/#/)\n* [THE 4 KEYS TO 100% UPTIME WITH NODE.JS](http://engineering.spanishdict.com/blog/2013/12/20/the-4-keys-to-100-uptime-with-nodejs)\n","source":"_posts/use-in-production.md","raw":"title: Node.js企业开发\ndate: 2013-11-21 11:30:14\ntags: 应用\n---\n从Node.js最初版本发布到现在已经走过了四年多的时间. 从最初的Web服务器, 到发展成为全面的后台环境, NPM从几百个Module到5万+, 且还在不断飞速增长, 从最初的JS开发者到现在的专门Node开发者以及众多的开发者大会和比赛. 从最初的Demo开发到LinkedIn, Paypal, groupon等大公司采用. Node已经渐渐成熟, 马上0.12版本就会到来, 届时Node API的将会确定下来. 这些都为Node在企业生产环境中大规模应用准备好了条件. N博客将会介绍一系列Node.js正式环境应用的相关内容.\n\n* Node.js适合应用场景\n* 如何开发高效, 健壮, 安全, 可扩展的Node应用\n* 项目架构, 文档, 私有NPM\n* Node项目调试, 测试, 异常处理, 容错\n* Node应用部署, 进程守护, cluster, 日志, 报警, nginx\n* Node服务监控, 内存泄露检测\n* 其他: benchmark\n\n#### 参考资料\n\n* [构建Node.js应用的10个重要的方面](http://tech.it168.com/a2013/0308/1460/000001460366.shtml)\n* [Towards 100% Uptime with Node.js](http://sandinmyjoints.github.io/towards-100-pct-uptime/#/)\n* [THE 4 KEYS TO 100% UPTIME WITH NODE.JS](http://engineering.spanishdict.com/blog/2013/12/20/the-4-keys-to-100-uptime-with-nodejs)\n","slug":"use-in-production","published":1,"updated":"2015-10-10T10:19:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifmere020006vs1mg6mqi0cn"},{"title":"Node & NPM upgrade","date":"2014-03-25T09:05:45.000Z","_content":"\nNode 和 Npm 升级节奏都非常快, 因此版本升级是 Noder 经常回碰到的事情.\n\n## NPM\nnpm 升级非常方便, 直接使用 npm 就可以\n\n```\n$ npm update -g npm\n```\n\nnpm 卸载方法如下\n```\n$ sudo npm uninstall npm -g\n```\n如果该方法失败, 可以先获取 npm 源代码, 然后\n\t\n    $ sudo make uninstall\n\n<!-- more -->\n\n## Node\n关于Node的安装[之前](http://n.thepana.com/2013/09/21/nodejs_install/)有详细的介绍, 具体方法可以移步过去看看.\n\n#### Installer, 系统软件管理工具, 版本管理工具\nMac 或 windows 使用 Installer 安装, 卸载或直接覆盖都比较容易\n\n如果使用 `brew, apt-get` 等系统管理软件, 都系统卸载或升级命令, 升级比较简单\n\nnvm, n 等版本管理工具基本没有升级的问题\n\n#### 下载binary, 添加PATH\n如果是下载binary, 添加PATH, 只需要将 node 目录换成最新即可\n\n\n#### 编译安装\n源码安装, 如果还保留源代码可以在, 源代码目录执行如下命令卸载\n\n\t$ sudo make uninstall\n    \n如果安装源码已经删掉, 则需要手动将所有node相关文件删掉. 先使用 which 命令找到 node 路径\n\n\t$ which node\n\n然后进入安装目录删掉相关文件\n\n\t$ rm -r bin/node bin/node-waf include/node lib/node lib/pkgconfig/nodejs.pc share/man/man1/node.1\n    \n其他位置 node_modules 手动删除即可\n\n参考:\n\n* [uninstall-node-js-using-linux-command-line](http://stackoverflow.com/questions/5650169/uninstall-node-js-using-linux-command-line)\n* [Removing Node.Js from Mountain Lion](http://stackoverflow.com/questions/14673327/removing-node-js-from-mountain-lion)\n* [How do I completely uninstall Node.js, and reinstall from beginning (Mac OS X)](http://stackoverflow.com/questions/11177954/how-do-i-completely-uninstall-node-js-and-reinstall-from-beginning-mac-os-x)","source":"_posts/upgrade-node-npm.md","raw":"title: Node & NPM upgrade\ndate: 2014-03-25 17:05:45\ntags:\n---\n\nNode 和 Npm 升级节奏都非常快, 因此版本升级是 Noder 经常回碰到的事情.\n\n## NPM\nnpm 升级非常方便, 直接使用 npm 就可以\n\n```\n$ npm update -g npm\n```\n\nnpm 卸载方法如下\n```\n$ sudo npm uninstall npm -g\n```\n如果该方法失败, 可以先获取 npm 源代码, 然后\n\t\n    $ sudo make uninstall\n\n<!-- more -->\n\n## Node\n关于Node的安装[之前](http://n.thepana.com/2013/09/21/nodejs_install/)有详细的介绍, 具体方法可以移步过去看看.\n\n#### Installer, 系统软件管理工具, 版本管理工具\nMac 或 windows 使用 Installer 安装, 卸载或直接覆盖都比较容易\n\n如果使用 `brew, apt-get` 等系统管理软件, 都系统卸载或升级命令, 升级比较简单\n\nnvm, n 等版本管理工具基本没有升级的问题\n\n#### 下载binary, 添加PATH\n如果是下载binary, 添加PATH, 只需要将 node 目录换成最新即可\n\n\n#### 编译安装\n源码安装, 如果还保留源代码可以在, 源代码目录执行如下命令卸载\n\n\t$ sudo make uninstall\n    \n如果安装源码已经删掉, 则需要手动将所有node相关文件删掉. 先使用 which 命令找到 node 路径\n\n\t$ which node\n\n然后进入安装目录删掉相关文件\n\n\t$ rm -r bin/node bin/node-waf include/node lib/node lib/pkgconfig/nodejs.pc share/man/man1/node.1\n    \n其他位置 node_modules 手动删除即可\n\n参考:\n\n* [uninstall-node-js-using-linux-command-line](http://stackoverflow.com/questions/5650169/uninstall-node-js-using-linux-command-line)\n* [Removing Node.Js from Mountain Lion](http://stackoverflow.com/questions/14673327/removing-node-js-from-mountain-lion)\n* [How do I completely uninstall Node.js, and reinstall from beginning (Mac OS X)](http://stackoverflow.com/questions/11177954/how-do-i-completely-uninstall-node-js-and-reinstall-from-beginning-mac-os-x)","slug":"upgrade-node-npm","published":1,"updated":"2015-10-12T04:36:03.000Z","_id":"cifmere050009vs1mtfdd7yop","comments":1,"layout":"post","photos":[],"link":""},{"title":"REPL","date":"2013-09-23T10:03:07.000Z","_content":"# What is [REPL](http://nodejs.org/api/repl.html) ?\nRead-Eval-Print-Loop(REPL)提供了交互式执行JS代码,查看结果的功能, 输入一行(块)代码, 可立刻看到执行结果. \n适用于调试, 测试, 尝试代码. 不止N, Ruby, Python, Lua等语言都提供了类似的交互式环境.\n\n<!-- more -->\n\n## 如何打开\n终端中命令`node`(不带参数)可以打开REPL. 它具有简单的Emacs行编辑.\n\n设置环境变量`NODE_NO_READLINE=1`然后执行`node`可以打开高级line-editors\n\n## repl.start(options)\nN的REPL不仅能独立运行还支持以编程的形式在其他程序中运行.\n```\nrepl = require(\"repl\")\nrepl.start({\n    prompt: \"node via stdin>\",\n    input: process.stdin,\n    output: process.stdout\n});\n```\n\noptions具体参数, 事件, 使用方式参看REPL [API](http://nodejs.org/api/repl.html)\n\n## Features\n\n* Control+D退出\n* 支持多行Expression\n* Tab 补全功能支持全局和局部变量\n* `_` 保存最后一个Expression的值\n* 特殊REPL命令(均以句号开头,在REPL中.help查看)\n    1 .break  清空多行Expression\n    2 .clear  重置context对象为空,清空多行Express\n    3 .exit   退出REPL\n    4 .help   打印帮助\n    5 .save   将REPL当前session保存到文件\n    6 .load   加载文件代码到REPL\n* Control+c一次相当于.break, 两次相当于.exit即退出\n\n## Last\n灵活运用REPL,可以给开发工作带来很多方便和帮助.关于REPL的更多内容请参看[官方文档](http://nodejs.org/api/repl.html)","source":"_posts/repl.md","raw":"title: REPL\ndate: 2013-09-23 18:03:07\ntags: REPL\n---\n# What is [REPL](http://nodejs.org/api/repl.html) ?\nRead-Eval-Print-Loop(REPL)提供了交互式执行JS代码,查看结果的功能, 输入一行(块)代码, 可立刻看到执行结果. \n适用于调试, 测试, 尝试代码. 不止N, Ruby, Python, Lua等语言都提供了类似的交互式环境.\n\n<!-- more -->\n\n## 如何打开\n终端中命令`node`(不带参数)可以打开REPL. 它具有简单的Emacs行编辑.\n\n设置环境变量`NODE_NO_READLINE=1`然后执行`node`可以打开高级line-editors\n\n## repl.start(options)\nN的REPL不仅能独立运行还支持以编程的形式在其他程序中运行.\n```\nrepl = require(\"repl\")\nrepl.start({\n    prompt: \"node via stdin>\",\n    input: process.stdin,\n    output: process.stdout\n});\n```\n\noptions具体参数, 事件, 使用方式参看REPL [API](http://nodejs.org/api/repl.html)\n\n## Features\n\n* Control+D退出\n* 支持多行Expression\n* Tab 补全功能支持全局和局部变量\n* `_` 保存最后一个Expression的值\n* 特殊REPL命令(均以句号开头,在REPL中.help查看)\n    1 .break  清空多行Expression\n    2 .clear  重置context对象为空,清空多行Express\n    3 .exit   退出REPL\n    4 .help   打印帮助\n    5 .save   将REPL当前session保存到文件\n    6 .load   加载文件代码到REPL\n* Control+c一次相当于.break, 两次相当于.exit即退出\n\n## Last\n灵活运用REPL,可以给开发工作带来很多方便和帮助.关于REPL的更多内容请参看[官方文档](http://nodejs.org/api/repl.html)","slug":"repl","published":1,"updated":"2015-10-12T04:36:07.000Z","_id":"cifmere08000avs1mkx29h61e","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js企业开发 五服务监控","date":"2014-01-27T09:19:04.000Z","_content":"服务监控对于正式环境应用和产品来说非常重要, 目前主流的语言平台都有完善的监控服务或解决方案, 虽然Node是一个年轻的平台, 但已经有不少成熟甚至商业化的监控服务.\n\n<!-- more -->\n\n# 云端监控服务\n目前比较成熟的监控服务都是基于云端的. 使用时需要在应用部署地方安装统计client, 负责将系统的运行状态数据发送到云端, 由云端进行处理分析并生成报表.\n\n## [StrongOps](http://strongloop.com/node-js-performance/strongops/)\nStrongOps 是 StrongLoop 提供的 Node 应用监控服务, 其原型是 Nodefly, 后来开发团队及技术被 StrongLoop 收购. 并持续开发对外提供服务. 是目前比较成熟的监控服务(Strongloop是Node代码贡献最多的公司). 具有众多功能:\n\n* 错误检测\n* 调试\n* CPU Profiling\n* 内存 Profiling\n* Transaction Profiling\n* 内存泄露检测\n* 性能监控\n* Cluster 管理\n* Endpoints & Databases\n\n![](http://public1.qiniudn.com/img/StrongLoop%20%20%20StrongOps.png.resized.png)\n\n\n## [NewRelic](http://newrelic.com/nodejs)\nNewRelic是一家专门提供监控服务的公司, 他们最开始提供RUBY, PHP, JAVA, .NET, PYTHON 等监控服务, 最近添加了对Node.js服务监控的支持. 目前他们的监控服务提供多元的数据监控.\n\n* Response time\n* Apdex score\n* Throughput (requests per minute)\n* Web transactions\n* Error rates\n* Recent events\n* Server information\n\n具体特点可参看他们的介绍网站, 或直接体验他们的服务.\n\n\n![](http://public1.qiniudn.com/img/Node.js%20Troubleshooting%20%20%20Performance%20Monitoring%20%20%20New%20Relic.png.resized.png)\n\n\n## [Nodetime](http://nodetime.com/)\nNodetime 最初也是由个人开发团队开发来用于服务监控的, 现在已经被AppDynamics公司收购. \n\n![](http://public1.qiniudn.com/img/Nodetime%20%20%20Performance%20Analytics%20for%20Node.js%20Applications%20%20Node.js%20APM.png.resized.png)\n\n## [concurix](http://www.concurix.com/home)\nconcurix 支持性能监控, 可视化的代码分析, 相对于上面三个服务它提供的服务更加有自己的特点, 可以查看事件循环等.\n\n![](http://public1.qiniudn.com/img/Concurix%20%20%20Node.js%20Monitoring%20and%20Profiling.png.resized.png)\n\n\n## 其他\n[NodePing](http://nodeping.com/) 和 [Graphdat](http://www.graphdat.com/) 也是两家提供监控服务的公司， 有兴趣的同学\n可以尝试一下.\n\n# [监控 Module](https://nodejsmodules.org/tags/profiler)\n除了这些云服务性质的监控服务外还有一些第三方Module 具有监控功能.\n\n## [PM2](https://github.com/Unitech/pm2)\nPM2 是一个进程守护工具， 现在也正在开发服务监控的功能， 目前还没有开发完成\n![](https://keymetrics.io/assets/images/application-demo.png?v=7214ee7be4)\n\n## [Node-Monitor](http://lorenwest.github.io/node-monitor/)\nNode-monitor是一个监控module， 简单，轻量， 灵活，稳定。\n\n## [WatchMen](https://github.com/iloire/WatchMen)\nWatchMen是一个Node.js监控服务Module，用于监控接口状态， 使用Express， ejs开发，\n具有web页面。\n\n## [node-memwatch](https://github.com/lloyd/node-memwatch)\nnode-memcatch会监控内存使用情况，对于发现和查找内存泄露非常有用\n\n\n\n# 总结\n虽然Node.js是一个年轻的平台，但现在可供使用的监控服务已然不少， 大家可以根据自身特点\n对多个服务或Module进行比较， 选择适合自己的工具\n\n","source":"_posts/performance-monitor.md","raw":"title: Node.js企业开发 五服务监控\ndate: 2014-01-27 17:19:04\ntags:\n---\n服务监控对于正式环境应用和产品来说非常重要, 目前主流的语言平台都有完善的监控服务或解决方案, 虽然Node是一个年轻的平台, 但已经有不少成熟甚至商业化的监控服务.\n\n<!-- more -->\n\n# 云端监控服务\n目前比较成熟的监控服务都是基于云端的. 使用时需要在应用部署地方安装统计client, 负责将系统的运行状态数据发送到云端, 由云端进行处理分析并生成报表.\n\n## [StrongOps](http://strongloop.com/node-js-performance/strongops/)\nStrongOps 是 StrongLoop 提供的 Node 应用监控服务, 其原型是 Nodefly, 后来开发团队及技术被 StrongLoop 收购. 并持续开发对外提供服务. 是目前比较成熟的监控服务(Strongloop是Node代码贡献最多的公司). 具有众多功能:\n\n* 错误检测\n* 调试\n* CPU Profiling\n* 内存 Profiling\n* Transaction Profiling\n* 内存泄露检测\n* 性能监控\n* Cluster 管理\n* Endpoints & Databases\n\n![](http://public1.qiniudn.com/img/StrongLoop%20%20%20StrongOps.png.resized.png)\n\n\n## [NewRelic](http://newrelic.com/nodejs)\nNewRelic是一家专门提供监控服务的公司, 他们最开始提供RUBY, PHP, JAVA, .NET, PYTHON 等监控服务, 最近添加了对Node.js服务监控的支持. 目前他们的监控服务提供多元的数据监控.\n\n* Response time\n* Apdex score\n* Throughput (requests per minute)\n* Web transactions\n* Error rates\n* Recent events\n* Server information\n\n具体特点可参看他们的介绍网站, 或直接体验他们的服务.\n\n\n![](http://public1.qiniudn.com/img/Node.js%20Troubleshooting%20%20%20Performance%20Monitoring%20%20%20New%20Relic.png.resized.png)\n\n\n## [Nodetime](http://nodetime.com/)\nNodetime 最初也是由个人开发团队开发来用于服务监控的, 现在已经被AppDynamics公司收购. \n\n![](http://public1.qiniudn.com/img/Nodetime%20%20%20Performance%20Analytics%20for%20Node.js%20Applications%20%20Node.js%20APM.png.resized.png)\n\n## [concurix](http://www.concurix.com/home)\nconcurix 支持性能监控, 可视化的代码分析, 相对于上面三个服务它提供的服务更加有自己的特点, 可以查看事件循环等.\n\n![](http://public1.qiniudn.com/img/Concurix%20%20%20Node.js%20Monitoring%20and%20Profiling.png.resized.png)\n\n\n## 其他\n[NodePing](http://nodeping.com/) 和 [Graphdat](http://www.graphdat.com/) 也是两家提供监控服务的公司， 有兴趣的同学\n可以尝试一下.\n\n# [监控 Module](https://nodejsmodules.org/tags/profiler)\n除了这些云服务性质的监控服务外还有一些第三方Module 具有监控功能.\n\n## [PM2](https://github.com/Unitech/pm2)\nPM2 是一个进程守护工具， 现在也正在开发服务监控的功能， 目前还没有开发完成\n![](https://keymetrics.io/assets/images/application-demo.png?v=7214ee7be4)\n\n## [Node-Monitor](http://lorenwest.github.io/node-monitor/)\nNode-monitor是一个监控module， 简单，轻量， 灵活，稳定。\n\n## [WatchMen](https://github.com/iloire/WatchMen)\nWatchMen是一个Node.js监控服务Module，用于监控接口状态， 使用Express， ejs开发，\n具有web页面。\n\n## [node-memwatch](https://github.com/lloyd/node-memwatch)\nnode-memcatch会监控内存使用情况，对于发现和查找内存泄露非常有用\n\n\n\n# 总结\n虽然Node.js是一个年轻的平台，但现在可供使用的监控服务已然不少， 大家可以根据自身特点\n对多个服务或Module进行比较， 选择适合自己的工具\n\n","slug":"performance-monitor","published":1,"updated":"2015-10-12T04:36:11.000Z","_id":"cifmere0a000dvs1mtv59c65l","comments":1,"layout":"post","photos":[],"link":""},{"title":"How to install N ?","date":"2013-09-21T10:09:25.000Z","_content":"\nN 是跨平台的, 支持 Linux, OSX, Windows, SunOS (也支持 ARM,但还不成熟,本文略过). 以上环境均支持 32 位和 64 位.  \n安装内容包括: 执行环境`node`, 包管理工具`npm`.\n\nN 大致有以下几种安装方式:\n\n* Installer\n* 系统软件管理工具\n* 版本管理工具\n* 下载binary, 添加path\n* 源码编译安装\n* 其他\n\n<!-- more -->\n\n相关链接: [下载地址](http://nodejs.org/download/), [Github源码](https://github.com/joyent/node)\n\n\n## Installer\nN 有 OSX, Windows 平台的 Installer, 可直接下载对应版本安装.  \nLinux, SunOS 有编译好的二进制文件, 下载解压后可放到任意位置, 然后将`N路径/bin`添加到PATH环境变量即可.\n\n## 系统软件管理工具\nOSX系统可使用 [Homebrew](http://brew.sh) 安装:\n\n    brew install node\n\nUbuntu系统可使 apt-get 安装:\n\n    sudo apt-get install nodejs npm\n\n[详情参看](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)\n\n\n## 版本管理工具安装\nRuby, Python都有自己的版本管理工具rvm, virtualenv. 用于安装,管理不同版本环境, 版本之间快速切换等操作. \n对于版本更迭频繁的N来说, 使用版本管理工具进行安装是不错的选择. 这里介绍N的版本管理工具 [nvm](https://github.com/creationix/nvm)\n\n### nvm 安装\nInstall nvm (use git):\n\n    curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n\nor Wget:\n\n    wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n\n这个脚本会下载nvm到~/.nvm, 然后在profile中添加source line\n\n### nvm 使用\n\n    nvm install 0.10    # 安装0.10版本\n    nvm use 0.10        # 使用0.10版本\n    nvm uninstall 0.10  # 卸载0.10版本\n\nnvm 的具体安装和使用参看 [nvm GitHub](https://github.com/creationix/nvm)\n\n另外[n](https://github.com/visionmedia/n), [nave](https://github.com/isaacs/nave) 也是 N 的版本管理工具\n\n\n## 下载binary, 添加PATH\nNode 官方有编译好的二进制文件, 下载后放到指定目录, 然后将路径添加到 PATH 环境变量即可\n\n\n## 编译安装\n首先到官网或 GitHub 下载源码\n### Unix\n\n#### Prerequisites:\n\n* GCC 4.2 or newer\n* Python 2.6 or 2.7\n* GNU Make 3.81 or newer\n* libexecinfo (FreeBSD and OpenBSD only)\n\nIn Mac:\n\n1. 安装 Xcode (包含编译依赖库)\n2. 安装 git (用于从 GitHub 获取代码)\n\nIn Ubuntu:\n\n1. sudo apt-get install g++ curl libssl-dev apache2-utils\n2. sudo apt-get install git-core\n\nIn CentOS:\n\n1. yum install gcc-c++\n\n#### Build\nUnix/Macintosh:\n\n    ./configure\n    make\n    make install\n\n如果 python 没有在标准位置或者没有标准的名字, 需要使用如下命令编译\n\n    export PYTHON=/path/to/python\n    $PYTHON ./configure\n    make\n    make install\n\n详细信息参看 [GitHub源码](https://github.com/joyent/node)\n\n\n## 其他\n有几个大公司提供了集成 N 的产品:\n\n* [StrongLoop](http://strongloop.com/strongloop-suite/downloads/)\n* Microsoft's [Webmatrix](http://www.microsoft.com/web/webmatrix/)\n\n\n## 测试\n在终端输入以下命令如果能看到版本号, 即安装成功:\n\n    node -v\n    # or\n    node --version\n\n\n## Tips\n\n* N 部分 Module 需要编译 在 Windows 下很难或无法安装, 建议使用 OSX 或 Linux 开发\n\n\n## 常见问题\n\n## 相关博客\n\n* [howtonode.org install instruction](http://howtonode.org/how-to-install-nodejs) (2011.3.11)\n* [CentOS install instruction](https://www.digitalocean.com/community/articles/how-to-install-and-run-a-node-js-app-on-centos-6-4-64bit)\n","source":"_posts/nodejs_install.md","raw":"title: How to install N ?\ndate: 2013-09-21 18:09:25\ntags: 安装\n---\n\nN 是跨平台的, 支持 Linux, OSX, Windows, SunOS (也支持 ARM,但还不成熟,本文略过). 以上环境均支持 32 位和 64 位.  \n安装内容包括: 执行环境`node`, 包管理工具`npm`.\n\nN 大致有以下几种安装方式:\n\n* Installer\n* 系统软件管理工具\n* 版本管理工具\n* 下载binary, 添加path\n* 源码编译安装\n* 其他\n\n<!-- more -->\n\n相关链接: [下载地址](http://nodejs.org/download/), [Github源码](https://github.com/joyent/node)\n\n\n## Installer\nN 有 OSX, Windows 平台的 Installer, 可直接下载对应版本安装.  \nLinux, SunOS 有编译好的二进制文件, 下载解压后可放到任意位置, 然后将`N路径/bin`添加到PATH环境变量即可.\n\n## 系统软件管理工具\nOSX系统可使用 [Homebrew](http://brew.sh) 安装:\n\n    brew install node\n\nUbuntu系统可使 apt-get 安装:\n\n    sudo apt-get install nodejs npm\n\n[详情参看](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)\n\n\n## 版本管理工具安装\nRuby, Python都有自己的版本管理工具rvm, virtualenv. 用于安装,管理不同版本环境, 版本之间快速切换等操作. \n对于版本更迭频繁的N来说, 使用版本管理工具进行安装是不错的选择. 这里介绍N的版本管理工具 [nvm](https://github.com/creationix/nvm)\n\n### nvm 安装\nInstall nvm (use git):\n\n    curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n\nor Wget:\n\n    wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n\n这个脚本会下载nvm到~/.nvm, 然后在profile中添加source line\n\n### nvm 使用\n\n    nvm install 0.10    # 安装0.10版本\n    nvm use 0.10        # 使用0.10版本\n    nvm uninstall 0.10  # 卸载0.10版本\n\nnvm 的具体安装和使用参看 [nvm GitHub](https://github.com/creationix/nvm)\n\n另外[n](https://github.com/visionmedia/n), [nave](https://github.com/isaacs/nave) 也是 N 的版本管理工具\n\n\n## 下载binary, 添加PATH\nNode 官方有编译好的二进制文件, 下载后放到指定目录, 然后将路径添加到 PATH 环境变量即可\n\n\n## 编译安装\n首先到官网或 GitHub 下载源码\n### Unix\n\n#### Prerequisites:\n\n* GCC 4.2 or newer\n* Python 2.6 or 2.7\n* GNU Make 3.81 or newer\n* libexecinfo (FreeBSD and OpenBSD only)\n\nIn Mac:\n\n1. 安装 Xcode (包含编译依赖库)\n2. 安装 git (用于从 GitHub 获取代码)\n\nIn Ubuntu:\n\n1. sudo apt-get install g++ curl libssl-dev apache2-utils\n2. sudo apt-get install git-core\n\nIn CentOS:\n\n1. yum install gcc-c++\n\n#### Build\nUnix/Macintosh:\n\n    ./configure\n    make\n    make install\n\n如果 python 没有在标准位置或者没有标准的名字, 需要使用如下命令编译\n\n    export PYTHON=/path/to/python\n    $PYTHON ./configure\n    make\n    make install\n\n详细信息参看 [GitHub源码](https://github.com/joyent/node)\n\n\n## 其他\n有几个大公司提供了集成 N 的产品:\n\n* [StrongLoop](http://strongloop.com/strongloop-suite/downloads/)\n* Microsoft's [Webmatrix](http://www.microsoft.com/web/webmatrix/)\n\n\n## 测试\n在终端输入以下命令如果能看到版本号, 即安装成功:\n\n    node -v\n    # or\n    node --version\n\n\n## Tips\n\n* N 部分 Module 需要编译 在 Windows 下很难或无法安装, 建议使用 OSX 或 Linux 开发\n\n\n## 常见问题\n\n## 相关博客\n\n* [howtonode.org install instruction](http://howtonode.org/how-to-install-nodejs) (2011.3.11)\n* [CentOS install instruction](https://www.digitalocean.com/community/articles/how-to-install-and-run-a-node-js-app-on-centos-6-4-64bit)\n","slug":"nodejs_install","published":1,"updated":"2015-10-12T04:36:18.000Z","_id":"cifmere0d000evs1mp42rkia1","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js--Evented I/O for V8 javascript","date":"2013-09-11T05:14:21.000Z","_content":"\n## What is Node.js\nNode.js是基于V8(Chrome开源JS引擎)和libuv的后端JS运行平台.\n\n官方描述:\n\n    Node.js is a platform built on Chrome's JavaScript runtime \n    for easily building fast, scalable network applications.\n    Node.js uses an event-driven, non-blocking I/O model \n    that makes it lightweight and efficient, perfect for \n    data-intensive real-time applications that run across distributed devices.\n\n中文翻译:\n\n    Node.js是基于Chrome JS引擎(V8)的平台. 能用于开发速度快,可扩展的网络应用. \n    它使用事件驱动、无阻塞模型, 从而具有轻量,高效的特性, 非常适合于开发运行在分布式设备上的\n    数据密集,实时型应用.\n\n## Node.js组成&原理\n\n### 组成\n\n* Node.js底层核心使用v8和libuv实现\n* 其上是C++和JS开发的Native Module\n* 再往上是npm和众多的第三方模块\n\n### 原理\n\n\n\n## Node.js优缺点\n### 优点\n* 开源\n* 高性能\n* 前后端可使用一种语言完成\n* 庞大的第三方模块\n* 活跃的开发者社区\n\n### 缺点\n* 不够成熟, 还未到1.0\n* 回调开发模式理解, 调试复杂\n* 第三方模块过多, 导致选择麻烦\n\n## Node.js历史,发展现状\n发展历史:\n\n* 2009.2，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库\n* 2009.5，Ryan Dahl在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用\n* 2009.11和2010.4，两届JSConf大会都安排了Node.js的讲座\n* 2010年年底，Node.js获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node.js的发展\n* 2011.7，Node.js在微软的支持下发布Windows版本\n* 2012.12.22，Luvit 0.6.0 发布，Lua 实现的 Node.js\n* 2013.9.4 v0.10.18发布\n\n现状(2013.9.22):\n\n* 有将近4万2千个第三方Module, 且还在快速增加当中\n* 许多大云服务都已支持Node.js, Amazon, Azure, baidu, alibaba, heroku, [nodejitsu](https://www.nodejitsu.com/)\n* Node.js性能还在不断提升\n* Node.js在2014年初即可实现1.0\n* Node.js有庞大的社区\n\n\n## 作者, 维护人员, 公司\n\n* Node.js 由 Ryan Dahl在2009年开发, 他是一个资深C++开发者\n* 目前主要由 Isaac Z. Schlueter(npm作者)开发和维护\n* Node.js是joyent(高性能云服务提供商)的产品\n\n\n## 相关博客和链接\n\n* Node.js [wiki](http://en.wikipedia.org/wiki/Nodejs) 和 [baike](http://baike.baidu.com/view/3974030.htm)\n* Node.js [GitHub](https://github.com/joyent/node)\n* [MIS Class Blog Node.js](http://misclassblog.com/interactive-web-development/node-js/)\n* [Node.js的核心与红利-朴灵(田永强)](http://www.programmer.com.cn/13844/)\n\n","source":"_posts/nodejs.md","raw":"title: Node.js--Evented I/O for V8 javascript\ndate: 2013-09-11 13:14:21\ntags: Intro\n---\n\n## What is Node.js\nNode.js是基于V8(Chrome开源JS引擎)和libuv的后端JS运行平台.\n\n官方描述:\n\n    Node.js is a platform built on Chrome's JavaScript runtime \n    for easily building fast, scalable network applications.\n    Node.js uses an event-driven, non-blocking I/O model \n    that makes it lightweight and efficient, perfect for \n    data-intensive real-time applications that run across distributed devices.\n\n中文翻译:\n\n    Node.js是基于Chrome JS引擎(V8)的平台. 能用于开发速度快,可扩展的网络应用. \n    它使用事件驱动、无阻塞模型, 从而具有轻量,高效的特性, 非常适合于开发运行在分布式设备上的\n    数据密集,实时型应用.\n\n## Node.js组成&原理\n\n### 组成\n\n* Node.js底层核心使用v8和libuv实现\n* 其上是C++和JS开发的Native Module\n* 再往上是npm和众多的第三方模块\n\n### 原理\n\n\n\n## Node.js优缺点\n### 优点\n* 开源\n* 高性能\n* 前后端可使用一种语言完成\n* 庞大的第三方模块\n* 活跃的开发者社区\n\n### 缺点\n* 不够成熟, 还未到1.0\n* 回调开发模式理解, 调试复杂\n* 第三方模块过多, 导致选择麻烦\n\n## Node.js历史,发展现状\n发展历史:\n\n* 2009.2，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库\n* 2009.5，Ryan Dahl在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用\n* 2009.11和2010.4，两届JSConf大会都安排了Node.js的讲座\n* 2010年年底，Node.js获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node.js的发展\n* 2011.7，Node.js在微软的支持下发布Windows版本\n* 2012.12.22，Luvit 0.6.0 发布，Lua 实现的 Node.js\n* 2013.9.4 v0.10.18发布\n\n现状(2013.9.22):\n\n* 有将近4万2千个第三方Module, 且还在快速增加当中\n* 许多大云服务都已支持Node.js, Amazon, Azure, baidu, alibaba, heroku, [nodejitsu](https://www.nodejitsu.com/)\n* Node.js性能还在不断提升\n* Node.js在2014年初即可实现1.0\n* Node.js有庞大的社区\n\n\n## 作者, 维护人员, 公司\n\n* Node.js 由 Ryan Dahl在2009年开发, 他是一个资深C++开发者\n* 目前主要由 Isaac Z. Schlueter(npm作者)开发和维护\n* Node.js是joyent(高性能云服务提供商)的产品\n\n\n## 相关博客和链接\n\n* Node.js [wiki](http://en.wikipedia.org/wiki/Nodejs) 和 [baike](http://baike.baidu.com/view/3974030.htm)\n* Node.js [GitHub](https://github.com/joyent/node)\n* [MIS Class Blog Node.js](http://misclassblog.com/interactive-web-development/node-js/)\n* [Node.js的核心与红利-朴灵(田永强)](http://www.programmer.com.cn/13844/)\n\n","slug":"nodejs","published":1,"updated":"2015-10-10T10:19:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifmere0h000hvs1mp4ju5vct"},{"title":"Nodejs native modules","date":"2013-09-17T08:46:02.000Z","_content":"Node.js目前的稳定版本为0.10, 很快会升级到0.12, 之后将是N粉翘首以待的1.0. 虽然目前还没有到达1.0\n但原生API已基本固定, 不会有很大变化. 想学好Node.js, 原生模块(API)是必须熟练知道的. 这里N将开始\n第一个博客系列--Native Module. 主要介绍Node.js的原生模块 并会涉及Node.js的内部架构和原理.\n\n<!-- more -->\n\nNode.js官方提供了英文原版的[API](http://nodejs.org/api/)文档. 可以一个页面查看所有模块, 也可以单模块查看,\n还提供了JSON版本的文档. 国内社区和开发者正在进行中文翻译工作, 可以到[这里](http://jsfuns.com/ebook/#30d25070-118c-11e3-bc83-47c9e4e1d529)查看目前的工作情况. 其他相关资源:\n\n* [overapi](http://overapi.com/nodejs/)\n* [nodejs.cn](http://nodejs.cn/)\n* [第三方](http://nodejsapi.cfapps.io/)\n* [nodetoolbox](http://nodetoolbox.com/)\n* [nodemanual](http://nodemanual.org/)\n* [nodejs中文翻译Github项目](https://github.com/pana/node-doc-cn)\n\nNode.js原生模块中有部分是全局变量或所有Module都包含的局部变量不要require可以直接使用. \n如: global, Buffer, require, module, console, process, timers, debugger.\n其他模块则可以通过require直接使用(不用安装).\n\nNode.js大致有33个原生模块.以下为根据模块的使用场景和使用频率将模块大致进行了划分.\n\n### core\n\n* Buffer\n* events\n* modules\n* stream\n* timers\n* globals\n\n### system\n\n* child processes\n* file system\n* OS\n* readline\n* process\n\n\n### network\n\n* DNS\n* HTTP\n* HTTPS\n* Net\n* TLS/SSL\n* TTY\n* UDP/datagram\n\n### utilities\n\n* Crypto\n* punycode\n* query strings\n* string decoder\n* url\n* path\n* utilities\n* zlib\n\n### debug\n\n* assertion testing\n* console\n* debugger\n\n### other\n\n* C/C++ Addons\n* Cluster\n* domain\n* REPL\n* vm\n\n\n在这些模块中有部分比较重要或经常使用:\n\n* events\n* globals\n* modules\n* timers\n* console\n* process\n* fs\n* http/https\n* query string\n* url\n* path\n* util\n\n\n本博客将会对这些原生模块逐一进行说明, 所有相关内容都属于Native module 系列.\n","source":"_posts/nodejs-native-modules.md","raw":"title: Nodejs native modules  \ndate: 2013-09-17 16:46:02  \ntags:  Native Module\n---\nNode.js目前的稳定版本为0.10, 很快会升级到0.12, 之后将是N粉翘首以待的1.0. 虽然目前还没有到达1.0\n但原生API已基本固定, 不会有很大变化. 想学好Node.js, 原生模块(API)是必须熟练知道的. 这里N将开始\n第一个博客系列--Native Module. 主要介绍Node.js的原生模块 并会涉及Node.js的内部架构和原理.\n\n<!-- more -->\n\nNode.js官方提供了英文原版的[API](http://nodejs.org/api/)文档. 可以一个页面查看所有模块, 也可以单模块查看,\n还提供了JSON版本的文档. 国内社区和开发者正在进行中文翻译工作, 可以到[这里](http://jsfuns.com/ebook/#30d25070-118c-11e3-bc83-47c9e4e1d529)查看目前的工作情况. 其他相关资源:\n\n* [overapi](http://overapi.com/nodejs/)\n* [nodejs.cn](http://nodejs.cn/)\n* [第三方](http://nodejsapi.cfapps.io/)\n* [nodetoolbox](http://nodetoolbox.com/)\n* [nodemanual](http://nodemanual.org/)\n* [nodejs中文翻译Github项目](https://github.com/pana/node-doc-cn)\n\nNode.js原生模块中有部分是全局变量或所有Module都包含的局部变量不要require可以直接使用. \n如: global, Buffer, require, module, console, process, timers, debugger.\n其他模块则可以通过require直接使用(不用安装).\n\nNode.js大致有33个原生模块.以下为根据模块的使用场景和使用频率将模块大致进行了划分.\n\n### core\n\n* Buffer\n* events\n* modules\n* stream\n* timers\n* globals\n\n### system\n\n* child processes\n* file system\n* OS\n* readline\n* process\n\n\n### network\n\n* DNS\n* HTTP\n* HTTPS\n* Net\n* TLS/SSL\n* TTY\n* UDP/datagram\n\n### utilities\n\n* Crypto\n* punycode\n* query strings\n* string decoder\n* url\n* path\n* utilities\n* zlib\n\n### debug\n\n* assertion testing\n* console\n* debugger\n\n### other\n\n* C/C++ Addons\n* Cluster\n* domain\n* REPL\n* vm\n\n\n在这些模块中有部分比较重要或经常使用:\n\n* events\n* globals\n* modules\n* timers\n* console\n* process\n* fs\n* http/https\n* query string\n* url\n* path\n* util\n\n\n本博客将会对这些原生模块逐一进行说明, 所有相关内容都属于Native module 系列.\n","slug":"nodejs-native-modules","published":1,"updated":"2015-10-12T04:36:34.000Z","_id":"cifmere0k000kvs1myry81k7b","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js企业开发 二应用开发","date":"2014-01-10T09:18:46.000Z","_content":"当确定什么场合适合使用 Node.js 开发之后, 需要考虑的问题就是如何开发了. 这里介绍下 Node.js 程序开发需要注意的一些问题.\n\n## 良好的程序应该具有的特点 \n这里笼统介绍几个好程序的特点, 详细内容可以参考网上资料.\n\n* 良好的架构\n* 高性能\n* 稳定和健壮\n* 可扩展, 易维护\n* 安全\n* 完善的测试, 文档, 良好的编码风格和注释\n* 其他: 易用, 美观等\n\n<!-- more -->\n\n## 架构设计\n一般的小项目, 大多数的程序员都是没有这个概念和环节的, 但是对于中大型和企业应用开发, 架构设计是必须和非常重要的. \n\n因为我目前是一个 Web 开发者, 并没有做过架构设计的工作, 所以这里只是介绍下我所了解和想到的地方.\n\n1. 首先需要了解需求, 了解项目特点. 需要实现什么功能, 程序使用特点, 访问量多大等等.\n2. 根据需求选择合适的技术和工具, 预估项目的开发量, 需要多少开发者, 花费多长时间, 解析设计项目架构, 如何分配工作并协调, 设定开发进度等等.\n3. 设计架构需要注意: 项目要模块化这样便于扩展,维护且让程序更加稳定; 问题, 工作量, 时间要预估充分; \n\n良好的架构是一切的基石, 只有架构好了才能保证高性能, 健壮, 可扩展, 提高开发速度, 降低成本.\n\n\n## 高性能\nNode 是一个高性能的 web 开发平台, 所以如何确保应用的高性能是一个非常重要的问题. 想要实现高性能可以根据 Node 的特点, 并参考大公司成熟的开发经验.\n\n想必大家都知道 LinkedIn 公司分享的代码高性能经验分享. 下面将他们列出, 具体的原因和细节可参考[原文](http://engineering.linkedin.com/nodejs/blazing-fast-nodejs-10-performance-tips-linkedin-mobile).\n这里面最重要的地方是--不要使用同步的代码, 异步是Node最大的特点, 也是它高效的原因, 所以在 Node 中一定不要使用同步代码, 除非你是写 demo, 本地测试.\n\n* 避免同步代码\n* 关闭socket池\n* 不要使用 Node.js 处理静态资源\n* 在客户端渲染页面\n* 开启 gzip 压缩\n* 并行代码\n* 避免使用 session\n* 使用 c++ 模块\n* 使用标准 V8 JavaScript 而不是客户端库\n* 保持小规模, 轻量级代码\n\n除了这几点, 还有不少方法可以加快程序速度\n\n* 使用 cluster 充分利用多核 CPU, 加快速度\n* 更高效的 JS 代码写法: 好的 JS 代码可以更快, 占用更少的内存\n* 使用性能检测工具查找程序瓶颈所在, 从而使程序变的更快\n\n## 稳定, 健壮\nNode 是单线程的, 任何没有捕捉的异常都会导致程序的结束和奔溃. 而程序稳定性是企业应用最看重的特性. 所以保证 Node 程序的稳定性是非常重要的.\n\n目前提高 Node 程序稳定性的方法主要有: 异常处理, 进程守护, 程序监控\n\n#### 异常处理\n\n* 不要忽略错误, 所有的错误都要进行处理\n* 使用 `try{...} catch(err){...}` 捕捉异常\n* 使用 `domains` 特性\n* 使用 `process.on(‘uncaughtException’, function(err){…}); ` 处理\n\n这里是一篇关于 Node.js 错误处理模式的[博客](http://www.nodewiz.biz/nodejs-error-handling-pattern/), 介绍的非常详细\n\n\n#### 进程守护\n* 使用 cluster \n* 使用 forever, pm2 等进程守护工具\n\n#### 程序监控\n* 添加服务监控, 异常时邮件, 短信等报警\n* 记录错误日志.\n\n## 其他\n\n* 可扩展\n* 测试\n* 调试, 内存泄露\n\n\n\n### 参考\n\n* [linkedin 高性能总结](http://engineering.linkedin.com/nodejs/blazing-fast-nodejs-10-performance-tips-linkedin-mobile)\n* [如何提高NodeJS程序运行的稳定性](http://blog.lovedan.cn/?p=222)\n* [如何提高Nodejs程序的稳定性和健壮性](http://blog.lovedan.cn/?p=186)\n* [Node.js实现网游服务器高性能和可扩展](http://developer.zdnet.com.cn/2012/1019/2126947.shtml)\n* [7 tips for a Node.js padawan](https://medium.com/tech-talk/e7c0b0e5ce3c)","source":"_posts/nodejs-gaoxingneng.md","raw":"title: Node.js企业开发 二应用开发\ndate: 2014-01-10 17:18:46\ntags:\n---\n当确定什么场合适合使用 Node.js 开发之后, 需要考虑的问题就是如何开发了. 这里介绍下 Node.js 程序开发需要注意的一些问题.\n\n## 良好的程序应该具有的特点 \n这里笼统介绍几个好程序的特点, 详细内容可以参考网上资料.\n\n* 良好的架构\n* 高性能\n* 稳定和健壮\n* 可扩展, 易维护\n* 安全\n* 完善的测试, 文档, 良好的编码风格和注释\n* 其他: 易用, 美观等\n\n<!-- more -->\n\n## 架构设计\n一般的小项目, 大多数的程序员都是没有这个概念和环节的, 但是对于中大型和企业应用开发, 架构设计是必须和非常重要的. \n\n因为我目前是一个 Web 开发者, 并没有做过架构设计的工作, 所以这里只是介绍下我所了解和想到的地方.\n\n1. 首先需要了解需求, 了解项目特点. 需要实现什么功能, 程序使用特点, 访问量多大等等.\n2. 根据需求选择合适的技术和工具, 预估项目的开发量, 需要多少开发者, 花费多长时间, 解析设计项目架构, 如何分配工作并协调, 设定开发进度等等.\n3. 设计架构需要注意: 项目要模块化这样便于扩展,维护且让程序更加稳定; 问题, 工作量, 时间要预估充分; \n\n良好的架构是一切的基石, 只有架构好了才能保证高性能, 健壮, 可扩展, 提高开发速度, 降低成本.\n\n\n## 高性能\nNode 是一个高性能的 web 开发平台, 所以如何确保应用的高性能是一个非常重要的问题. 想要实现高性能可以根据 Node 的特点, 并参考大公司成熟的开发经验.\n\n想必大家都知道 LinkedIn 公司分享的代码高性能经验分享. 下面将他们列出, 具体的原因和细节可参考[原文](http://engineering.linkedin.com/nodejs/blazing-fast-nodejs-10-performance-tips-linkedin-mobile).\n这里面最重要的地方是--不要使用同步的代码, 异步是Node最大的特点, 也是它高效的原因, 所以在 Node 中一定不要使用同步代码, 除非你是写 demo, 本地测试.\n\n* 避免同步代码\n* 关闭socket池\n* 不要使用 Node.js 处理静态资源\n* 在客户端渲染页面\n* 开启 gzip 压缩\n* 并行代码\n* 避免使用 session\n* 使用 c++ 模块\n* 使用标准 V8 JavaScript 而不是客户端库\n* 保持小规模, 轻量级代码\n\n除了这几点, 还有不少方法可以加快程序速度\n\n* 使用 cluster 充分利用多核 CPU, 加快速度\n* 更高效的 JS 代码写法: 好的 JS 代码可以更快, 占用更少的内存\n* 使用性能检测工具查找程序瓶颈所在, 从而使程序变的更快\n\n## 稳定, 健壮\nNode 是单线程的, 任何没有捕捉的异常都会导致程序的结束和奔溃. 而程序稳定性是企业应用最看重的特性. 所以保证 Node 程序的稳定性是非常重要的.\n\n目前提高 Node 程序稳定性的方法主要有: 异常处理, 进程守护, 程序监控\n\n#### 异常处理\n\n* 不要忽略错误, 所有的错误都要进行处理\n* 使用 `try{...} catch(err){...}` 捕捉异常\n* 使用 `domains` 特性\n* 使用 `process.on(‘uncaughtException’, function(err){…}); ` 处理\n\n这里是一篇关于 Node.js 错误处理模式的[博客](http://www.nodewiz.biz/nodejs-error-handling-pattern/), 介绍的非常详细\n\n\n#### 进程守护\n* 使用 cluster \n* 使用 forever, pm2 等进程守护工具\n\n#### 程序监控\n* 添加服务监控, 异常时邮件, 短信等报警\n* 记录错误日志.\n\n## 其他\n\n* 可扩展\n* 测试\n* 调试, 内存泄露\n\n\n\n### 参考\n\n* [linkedin 高性能总结](http://engineering.linkedin.com/nodejs/blazing-fast-nodejs-10-performance-tips-linkedin-mobile)\n* [如何提高NodeJS程序运行的稳定性](http://blog.lovedan.cn/?p=222)\n* [如何提高Nodejs程序的稳定性和健壮性](http://blog.lovedan.cn/?p=186)\n* [Node.js实现网游服务器高性能和可扩展](http://developer.zdnet.com.cn/2012/1019/2126947.shtml)\n* [7 tips for a Node.js padawan](https://medium.com/tech-talk/e7c0b0e5ce3c)","slug":"nodejs-gaoxingneng","published":1,"updated":"2015-10-12T04:36:45.000Z","_id":"cifmere0o000nvs1ms22y7l59","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js 0.12 全解","date":"2014-04-08T06:52:15.000Z","banner":null,"_content":"\nNode 0.12 马上就会发布, 距离 0.10 发布已有一年多的时间, 该版本不仅增加了多个重大 API, 还大幅度提升了速度. 0.12 也是 1.0 之前最后一个重大版本. 至此 Node 的 API 基本固定, 为企业化大规模应用做好准备. \n\n<!-- more -->\n\n\n## New API\n\n* [stream3]()\n* [spawnSync, execSync, execFileSync](http://strongloop.com/strongblog/whats-new-in-node-js-v0-12-execsync-a-synchronous-api-for-child-processes/)\n* [multiple execution contexts from within the same event loop](http://strongloop.com/strongblog/whats-new-node-js-v0-12-multiple-context-execution/)\n* profiling API\n* smalloc\n* asynclisteners\n\n## Speed up\n\n### writable streams 增加 cork 支持\n写入流增加了类似 `man tcp` 的 `TCP_CORK` 和 `TCP_NOPUSH` socket 选项支持. 当流处于 corked 状态, 写进流的数据会进行队列处理, 直到流回到 uncorked 状态. 这样 Node.js 可以将小数据写入组装成大数据写入, 从而减少系统调用和 TCP 往返.\n\nhttp 模块已经进行升级, 在发送 chunked 的请求和响应时, 会使用 corked 模式. 通过 strace 输出可以看到增加了 writev 调用, 减少了 write 调用.\n\n### TLS 性能提升\ntls 模块在 v0.12 中是完全不同的工作方式\n\nNode.js v0.10 tls 建立在 net 模块之上, 在传输 stream 时透明的进行加密和解密, 从工程学角度这层是根本没有必要的, 还会带来额外消耗(更多的内存移动, 更多的 V8 VM 调入调出). v0.12 重写直接使用 libuv, 直接从 wire 获取数据进行解密, 而不用经过中间层. \n\n在非正式的测试中, 带来了 10% 的性能提升和更小的内存使用.\n\n这些改变对于用户来说都是透明的, 但有一个需要用户注意 TLS 的连接现在继承自 `tls.TLSSocket`, 而之前是 `tls.CryptoStream`\n\n### Crypto 性能提升\n多个加密算法在 0.12 中将会更快, 具体提升细节参看下面 strongloop 原文\n\n### Reduced garbage collector strain\nmulti-context 重构带来的一个重大好处是, 他极大的降低了 Node.js 内核持久句柄的数量.\n\nmulti-context cleanup 工作的一部分是, 许多持久句柄被去掉或使用其他更加轻量的机制实现, \n所到来的好处就是应用可以在垃圾回收上花费更少的时间. 现在 `v8::internal::GlobalHandles::PostGarbageCollectionProcessing()` 应该会有更少的 `node –prof` 输出.\n\n关于持久句柄的定义和作用可以参看 strongloop 原文的对应部分.\n\n### 更好的 cluster 性能\nv0.10 中的 cluster 模块依赖系统将发送过来的请求平均分配给多个 worker.\n在 Solaris 和 linux 上一直重负荷工作量导致这种非配非常不平衡, v0.12 的分配方式切换为 [轮转法负载均衡](http://www.infoq.com/cn/articles/nodejs-cluster-round-robin-load-balancing)\n\n### 更快的 timers, setImmediate(), process.nextTick()\nsetTimeout() 和 相关方法现在使用更快和更准的 time source. 该优化在所有平台上都得到提升, 在 linux 上通过直接从 VDSO 获取当前时间(极大的降低了 gettimeofday 和 clock_gettime 的系统调用时间), 更进一步提升了性能\n\nsetImmediate() 和 process.nextTick() 也通过添加更快的分发路径提升了速度. Said 方法已经很快了, 现在也更快了\n\n[0.12 性能优化原文](http://www.infoq.com/cn/articles/nodejs-v012-optimize-performance)\n\n\n## ES6\n下一代 JavaScript 标准 ES6 (代号 harmony), 基本已经定型, V8 引擎陆续开始增加对 ES6 的支持. 在该版本中增加了众多语言特性如迭代器, 生成器, with语句, Set, Map 等, 将会给 JS 带来全新的发展空间. \n\n0.11.9 可以开启的 ES6 特性\n\n```\n$ node --v8-options | grep harmony\n  --harmony_typeof (enable harmony semantics for typeof)\n  --harmony_scoping (enable harmony block scoping)\n  --harmony_modules (enable harmony modules (implies block scoping))\n  --harmony_symbols (enable harmony symbols (a.k.a. private names))\n  --harmony_proxies (enable harmony proxies)\n  --harmony_collections (enable harmony collections (sets, maps, and weak maps))\n  --harmony_observation (enable harmony object observation (implies harmony collections)\n  --harmony_generators (enable harmony generators)\n  --harmony_iteration (enable harmony iteration (for-of))\n  --harmony_numeric_literals (enable harmony numeric literals (0o77, 0b11))\n  --harmony_strings (enable harmony string)\n  --harmony_arrays (enable harmony arrays)\n  --harmony_maths (enable harmony math functions)\n  --harmony (enable all harmony features (except typeof))\n```\n\n\n* [ES6 for Node](http://dailyjs.com/2012/10/15/preparing-for-esnext/)\n* [ECMAScript 6 compatibility table](http://kangax.github.io/es5-compat-table/es6/)\n* [ECMAScript Support Matrix](http://pointedears.de/scripts/test/es-matrix/)\n* [Google’s V8: Harmony features with corresponding open bugs in on the tracker](https://code.google.com/p/v8/issues/list?q=label:Harmony)\n* [Tracking ECMAScript 6 Support](http://addyosmani.com/blog/tracking-es6-support/)\n\n\n## VM improvements\n\n\n## Influence\n\n* [Node’s new leader, TJ Fontaine, explains why version 0.12 will blow developers’ minds](http://venturebeat.com/2014/03/12/nodes-new-leader-tj-fontaine-explains-why-version-0-12-will-blow-developers-minds/)\n\n## RoadMap\n1.0 将会超级的快\n\n* [Beyond Node.js v0.12: Thoughts on a Roadmap for the Future](http://strongloop.com/strongblog/node-js-v0-12-roadmap-for-the-future/)\n* [Node.js and the Road Ahead](http://blog.nodejs.org/2014/01/16/nodejs-road-ahead/)\n* [The Future of Programming in Node.js](http://cnodejs.org/topic/520af1c044e76d216a1dcc8a)\n\n\n## 参考\n\n* [What’s New in Node.js v0.12: Debugging Clustered Apps with Node-Inspector](http://strongloop.com/strongblog/whats-new-nodejs-v0-12-debugging-clusters/)\n* [What’s New in Node.js V0.12 (video)](http://strongloop.com/developers/videos/#whats-new-in-nodejs-v012)\n* [Node.js boosts load balancing, adds to API ahead of 1.0 release](http://www.infoworld.com/t/javascript/nodejs-boosts-load-balancing-adds-api-ahead-of-10-release-232105)\n* [round-robin](http://strongloop.com/strongblog/whats-new-in-node-js-v0-12-cluster-round-robin-load-balancing/)\n* [在单进程中跑多个实例](http://www.infoq.com/cn/articles/nodejs-v012-new-characteristic)\n* [What’s New in Node.js v0.12 – Performance Optimizations](http://strongloop.com/strongblog/performance-node-js-v-0-12-whats-new/)\n\n##### TODO\n\n* New API 详解\n* 0.12 影响分析\n* 未来发展规划分析","source":"_posts/node012-upgrade.md","raw":"title: Node.js 0.12 全解\ndate: 2014-04-8 14:52:15\ntags:\nbanner: \n---\n\nNode 0.12 马上就会发布, 距离 0.10 发布已有一年多的时间, 该版本不仅增加了多个重大 API, 还大幅度提升了速度. 0.12 也是 1.0 之前最后一个重大版本. 至此 Node 的 API 基本固定, 为企业化大规模应用做好准备. \n\n<!-- more -->\n\n\n## New API\n\n* [stream3]()\n* [spawnSync, execSync, execFileSync](http://strongloop.com/strongblog/whats-new-in-node-js-v0-12-execsync-a-synchronous-api-for-child-processes/)\n* [multiple execution contexts from within the same event loop](http://strongloop.com/strongblog/whats-new-node-js-v0-12-multiple-context-execution/)\n* profiling API\n* smalloc\n* asynclisteners\n\n## Speed up\n\n### writable streams 增加 cork 支持\n写入流增加了类似 `man tcp` 的 `TCP_CORK` 和 `TCP_NOPUSH` socket 选项支持. 当流处于 corked 状态, 写进流的数据会进行队列处理, 直到流回到 uncorked 状态. 这样 Node.js 可以将小数据写入组装成大数据写入, 从而减少系统调用和 TCP 往返.\n\nhttp 模块已经进行升级, 在发送 chunked 的请求和响应时, 会使用 corked 模式. 通过 strace 输出可以看到增加了 writev 调用, 减少了 write 调用.\n\n### TLS 性能提升\ntls 模块在 v0.12 中是完全不同的工作方式\n\nNode.js v0.10 tls 建立在 net 模块之上, 在传输 stream 时透明的进行加密和解密, 从工程学角度这层是根本没有必要的, 还会带来额外消耗(更多的内存移动, 更多的 V8 VM 调入调出). v0.12 重写直接使用 libuv, 直接从 wire 获取数据进行解密, 而不用经过中间层. \n\n在非正式的测试中, 带来了 10% 的性能提升和更小的内存使用.\n\n这些改变对于用户来说都是透明的, 但有一个需要用户注意 TLS 的连接现在继承自 `tls.TLSSocket`, 而之前是 `tls.CryptoStream`\n\n### Crypto 性能提升\n多个加密算法在 0.12 中将会更快, 具体提升细节参看下面 strongloop 原文\n\n### Reduced garbage collector strain\nmulti-context 重构带来的一个重大好处是, 他极大的降低了 Node.js 内核持久句柄的数量.\n\nmulti-context cleanup 工作的一部分是, 许多持久句柄被去掉或使用其他更加轻量的机制实现, \n所到来的好处就是应用可以在垃圾回收上花费更少的时间. 现在 `v8::internal::GlobalHandles::PostGarbageCollectionProcessing()` 应该会有更少的 `node –prof` 输出.\n\n关于持久句柄的定义和作用可以参看 strongloop 原文的对应部分.\n\n### 更好的 cluster 性能\nv0.10 中的 cluster 模块依赖系统将发送过来的请求平均分配给多个 worker.\n在 Solaris 和 linux 上一直重负荷工作量导致这种非配非常不平衡, v0.12 的分配方式切换为 [轮转法负载均衡](http://www.infoq.com/cn/articles/nodejs-cluster-round-robin-load-balancing)\n\n### 更快的 timers, setImmediate(), process.nextTick()\nsetTimeout() 和 相关方法现在使用更快和更准的 time source. 该优化在所有平台上都得到提升, 在 linux 上通过直接从 VDSO 获取当前时间(极大的降低了 gettimeofday 和 clock_gettime 的系统调用时间), 更进一步提升了性能\n\nsetImmediate() 和 process.nextTick() 也通过添加更快的分发路径提升了速度. Said 方法已经很快了, 现在也更快了\n\n[0.12 性能优化原文](http://www.infoq.com/cn/articles/nodejs-v012-optimize-performance)\n\n\n## ES6\n下一代 JavaScript 标准 ES6 (代号 harmony), 基本已经定型, V8 引擎陆续开始增加对 ES6 的支持. 在该版本中增加了众多语言特性如迭代器, 生成器, with语句, Set, Map 等, 将会给 JS 带来全新的发展空间. \n\n0.11.9 可以开启的 ES6 特性\n\n```\n$ node --v8-options | grep harmony\n  --harmony_typeof (enable harmony semantics for typeof)\n  --harmony_scoping (enable harmony block scoping)\n  --harmony_modules (enable harmony modules (implies block scoping))\n  --harmony_symbols (enable harmony symbols (a.k.a. private names))\n  --harmony_proxies (enable harmony proxies)\n  --harmony_collections (enable harmony collections (sets, maps, and weak maps))\n  --harmony_observation (enable harmony object observation (implies harmony collections)\n  --harmony_generators (enable harmony generators)\n  --harmony_iteration (enable harmony iteration (for-of))\n  --harmony_numeric_literals (enable harmony numeric literals (0o77, 0b11))\n  --harmony_strings (enable harmony string)\n  --harmony_arrays (enable harmony arrays)\n  --harmony_maths (enable harmony math functions)\n  --harmony (enable all harmony features (except typeof))\n```\n\n\n* [ES6 for Node](http://dailyjs.com/2012/10/15/preparing-for-esnext/)\n* [ECMAScript 6 compatibility table](http://kangax.github.io/es5-compat-table/es6/)\n* [ECMAScript Support Matrix](http://pointedears.de/scripts/test/es-matrix/)\n* [Google’s V8: Harmony features with corresponding open bugs in on the tracker](https://code.google.com/p/v8/issues/list?q=label:Harmony)\n* [Tracking ECMAScript 6 Support](http://addyosmani.com/blog/tracking-es6-support/)\n\n\n## VM improvements\n\n\n## Influence\n\n* [Node’s new leader, TJ Fontaine, explains why version 0.12 will blow developers’ minds](http://venturebeat.com/2014/03/12/nodes-new-leader-tj-fontaine-explains-why-version-0-12-will-blow-developers-minds/)\n\n## RoadMap\n1.0 将会超级的快\n\n* [Beyond Node.js v0.12: Thoughts on a Roadmap for the Future](http://strongloop.com/strongblog/node-js-v0-12-roadmap-for-the-future/)\n* [Node.js and the Road Ahead](http://blog.nodejs.org/2014/01/16/nodejs-road-ahead/)\n* [The Future of Programming in Node.js](http://cnodejs.org/topic/520af1c044e76d216a1dcc8a)\n\n\n## 参考\n\n* [What’s New in Node.js v0.12: Debugging Clustered Apps with Node-Inspector](http://strongloop.com/strongblog/whats-new-nodejs-v0-12-debugging-clusters/)\n* [What’s New in Node.js V0.12 (video)](http://strongloop.com/developers/videos/#whats-new-in-nodejs-v012)\n* [Node.js boosts load balancing, adds to API ahead of 1.0 release](http://www.infoworld.com/t/javascript/nodejs-boosts-load-balancing-adds-api-ahead-of-10-release-232105)\n* [round-robin](http://strongloop.com/strongblog/whats-new-in-node-js-v0-12-cluster-round-robin-load-balancing/)\n* [在单进程中跑多个实例](http://www.infoq.com/cn/articles/nodejs-v012-new-characteristic)\n* [What’s New in Node.js v0.12 – Performance Optimizations](http://strongloop.com/strongblog/performance-node-js-v-0-12-whats-new/)\n\n##### TODO\n\n* New API 详解\n* 0.12 影响分析\n* 未来发展规划分析","slug":"node012-upgrade","published":1,"updated":"2015-10-11T11:08:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifmere0r000ovs1m46j78nzm"},{"title":"Node.js企业开发 一应用场景","date":"2014-01-06T13:40:29.000Z","_content":"要想用Node.js首先需要知道它到底是什么, 有哪些优缺点. 然后我们才能知道到底 Node.js 适合哪些应用场景.\n\n<!-- more -->\n\n# Node.js\n\n[维基百科](http://en.wikipedia.org/wiki/Nodejs)：“Node.js 是谷歌 V8 引擎、libuv平台抽象层 以及主体使用 Javscript 编写的核心库三者集合的一个包装外壳。” Node.js的作者瑞恩·达尔 (Ryan Dahl) 给了开发者一个使用事件驱动来实现异步开发的优秀解决方案。\n\nNode.js 的主要思路是：使用非阻塞的，事件驱动的 I/O 操作来保持在处理跨平台 (across distributed devices) 数据密集型实时应用时的轻巧高效。\n\n它的 Web 工作原理跟传统网络技术大不相同. 传统的网络服务技术，是每个新增一个连接（请求）便生成一个新的线程，这个新的线程会占用系统内存，最终会占掉所有的可用内存。而 Node.js 仅仅只运行在一个单线程中，使用非阻塞的异步 I/O 调用，所有连接都由该线程处理，在 libuv 的加分下，可以允许其支持数万并发连接（全部挂在该线程的事件循环中）。\n\n当然这也有它自身的缺点: 大量的计算可能会使得 Node 的单线程暂时失去反应, 并导致所有的其他客户端的请求一直阻塞, 直到计算结束才恢复正常。 其次，开发人员需要非常小心，不要让一个 Exception 阻塞核心的事件循环，因为这将导致 Node.js 实例的终止.\n\nNode.js 具有以下特点:\n\n* 单线程\n* 事件驱动, 非阻塞\n* JS语言\n* Google V8\n\n所以它具有以下优点:\n\n* 系统资源(内存)占用少, 高访问量时更明显\n* 速度快(远快于php, python, ruby)\n* 前后端使用JS, 统一开发语言, 学习成本低, 社区活跃, NPM发展异常快\n* 善于处理高并发量的请求\n\n同事也有他的缺点: \n\n* 单线程不健壮\n* 平台较新, 不稳定\n* 调试不方便, 回调嵌套代码难读\n* Module太多, 质量不一\n\n注：V8是谷歌开发的，目前公认最快的 Javascript 解析引擎，libuv 是一个开源的、为 Node 定制而生的跨平台的异步 IO 库。\n\n\n# 应用场景\n\nNode.js 适合解决特定问题, 在一些领域并不适合使用:\n\n* CPU 密集型应用 \n* Simple CRUD / HTML apps\n* 数据库依赖复杂; 业务逻辑和验证复杂的应用\n* 需要管理界面的应用\n* 大型企业应用\n\nNode.js适合于 IO 密集而非计算密集的情景；高并发微数据（比如账号系统）的情景; Node.js也适用于开发实时应用.\n\n## RESTful API/ JSON API/ Mobile backend API\n提供 RESTful API 的 Web 服务接收参数，解析，组合响应，并返回响应（通常是较少的文本）给用户。这是适合 Node 的理想情况，因为您可以构建它来处理数万条连接。它仍然不需要大量逻辑；它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的 API 需求。\n\n\n## 实时程序\nnode.js另一个很大的方面是你可以很轻松的开发软实时系统。这是指那些像twitter，聊天软件，体彩或实时通讯网络的接口, 游戏.\n\n## 单页的app\n如果你打算写一个AJAX操作非常多的单页面app（比如gmail），node.js是非常合适的。在极短的响应时间内处理大量请求的能力，不同的客户端共享像确认信息之类的东西，这些都让node.js成为那种在客户端做很多处理的web程序的很好的选择。\n\n## 流数据\n传统的web程序讲http请求和响应作为元事件处理。可事实是它们是流，很多很酷的node.js程序正是利用这个优点创建的。最牛的例子是实时解析上传文件，还在不同的数据层建立了代理。\n\n## 对unix工具的脚本化调用\nnode.js现在还很年轻，它正在试图为自己重新发明各种软件，不过更好的办法是深入到现有的广阔的命令行工具世界里。Node.js拥有产生数以千计的子进程的能力，同时可以把这些子进程的输出以流的方式处理，这让它成为那种和现有软件寻求平衡时的很好的选择\n\n## 电子游戏统计数据\n如果您在线玩过《使命召唤》这款游戏，当您查看游戏统计数据时，就会立即意识到一个问题：要生成那种级别的统计数据，必须跟踪海量信息。这样，如果有数百万玩家同时在线玩游戏，而且他们处于游戏中的不同位置，那么很快就会生成海量信息。Node 是这种场景的一种很好的解决方案，因为它能采集游戏生成的数据，对数据进行最少的合并，然后对数据进行排队，以便将它们写入数据库。使用整个服务器来跟踪玩家在游戏中发射了多少子弹看起来很愚蠢，如果您使用 Apache 这样的服务器，可能会 有一些有用的限制；但相反，如果您专门使用一个服务器来跟踪一个游戏的所有统计数据，就像使用运行 Node 的服务器所做的那样，那看起来似乎是一种明智之举。\n\n\n# 总结\nNode.js是一个年轻的平台, 不久就会迎来自己的成人礼(1.0大概会在2014年发布). Node有它自己的一些优点, 也有各种各样的问题. 但最让人欣慰的是越来越多的开发者加入进来, 促进Node.js不断完善, 应用到更多的领域当中. 即最重要的是它在不断的前进.\n\n关于Node.js到底适合应用于何种场景, 只要看看业界对Node.js的采用情况就知道了. LinkedIn, WaltmartLab, Yahoo, ebay, Paypal... 而且这是最可靠, 最及时的.\n\n[StrongLoop](http://strongloop.com/strongblog/) 的 In the loop 和 Mobile News Round-up会定期总结一些Node.js最新的应用情况, 另外 [Google news](https://www.google.com.hk/search?hl=en&gl=us&tbm=nws&authuser=0&q=nodejs&oq=nodejs&gs_l=news-cc.3..43j43i53.1468.2073.0.2456.6.4.0.2.0.1.148.288.2j2.4.0...0.0...1ac.1.BWenTbq3spg) 也是了解Node.js最新动态的好地方\n\n\n### 参考\n\n* [IBM--Node.js究竟是什么](http://www.ibm.com/developerworks/cn/opensource/os-nodejs/)\n* [How to decide when to use Node.js](http://blog.lovedan.cn/?p=266)\n* [推酷--Node.js 优缺点及适用场景讨论](http://www.tuicool.com/articles/nAjYNf)\n* [Felix Node.js guide--说服老板](http://nodeguide.com/convincing_the_boss.html)\n* [说服老板中文翻译](http://cssor.com/suitable-for-the-scene-of-nodejs-use.html) \n* [知乎--使用 Node.js 的优势和劣势都有哪些？有大公司用吗？](http://www.zhihu.com/question/19653241)\n* [知乎--Node.js 发展前景如何？适用于哪些场景？](http://www.zhihu.com/question/19587881)\n* [segmentfault--实例说明为什么应使用 Node.js](http://segmentfault.com/a/1190000000375619)\n* [为什么我要用 Node.js? 案例逐一介绍](http://developer.51cto.com/art/201312/425921.htm)\n* [stackoverflow--How to decide when to use NodeJS?](http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-nodejs)\n* [Node.js is taking over the Enterprise – whether you like it or not](http://blog.appfog.com/node-js-is-taking-over-the-enterprise-whether-you-like-it-or-not/)\n* [Infoq--廖恺谈NodeJS在淘宝的应用](http://www.infoq.com/cn/interviews/lk-nodejs-taobao)\n* [NodeJS与Rails何去何从？](http://tech.it168.com/a2011/0914/1245/000001245990.shtml)\n\n\n","source":"_posts/node-yingyong-changjing.md","raw":"title: Node.js企业开发 一应用场景\ndate: 2014-01-06 21:40:29\ntags: 应用场景\n---\n要想用Node.js首先需要知道它到底是什么, 有哪些优缺点. 然后我们才能知道到底 Node.js 适合哪些应用场景.\n\n<!-- more -->\n\n# Node.js\n\n[维基百科](http://en.wikipedia.org/wiki/Nodejs)：“Node.js 是谷歌 V8 引擎、libuv平台抽象层 以及主体使用 Javscript 编写的核心库三者集合的一个包装外壳。” Node.js的作者瑞恩·达尔 (Ryan Dahl) 给了开发者一个使用事件驱动来实现异步开发的优秀解决方案。\n\nNode.js 的主要思路是：使用非阻塞的，事件驱动的 I/O 操作来保持在处理跨平台 (across distributed devices) 数据密集型实时应用时的轻巧高效。\n\n它的 Web 工作原理跟传统网络技术大不相同. 传统的网络服务技术，是每个新增一个连接（请求）便生成一个新的线程，这个新的线程会占用系统内存，最终会占掉所有的可用内存。而 Node.js 仅仅只运行在一个单线程中，使用非阻塞的异步 I/O 调用，所有连接都由该线程处理，在 libuv 的加分下，可以允许其支持数万并发连接（全部挂在该线程的事件循环中）。\n\n当然这也有它自身的缺点: 大量的计算可能会使得 Node 的单线程暂时失去反应, 并导致所有的其他客户端的请求一直阻塞, 直到计算结束才恢复正常。 其次，开发人员需要非常小心，不要让一个 Exception 阻塞核心的事件循环，因为这将导致 Node.js 实例的终止.\n\nNode.js 具有以下特点:\n\n* 单线程\n* 事件驱动, 非阻塞\n* JS语言\n* Google V8\n\n所以它具有以下优点:\n\n* 系统资源(内存)占用少, 高访问量时更明显\n* 速度快(远快于php, python, ruby)\n* 前后端使用JS, 统一开发语言, 学习成本低, 社区活跃, NPM发展异常快\n* 善于处理高并发量的请求\n\n同事也有他的缺点: \n\n* 单线程不健壮\n* 平台较新, 不稳定\n* 调试不方便, 回调嵌套代码难读\n* Module太多, 质量不一\n\n注：V8是谷歌开发的，目前公认最快的 Javascript 解析引擎，libuv 是一个开源的、为 Node 定制而生的跨平台的异步 IO 库。\n\n\n# 应用场景\n\nNode.js 适合解决特定问题, 在一些领域并不适合使用:\n\n* CPU 密集型应用 \n* Simple CRUD / HTML apps\n* 数据库依赖复杂; 业务逻辑和验证复杂的应用\n* 需要管理界面的应用\n* 大型企业应用\n\nNode.js适合于 IO 密集而非计算密集的情景；高并发微数据（比如账号系统）的情景; Node.js也适用于开发实时应用.\n\n## RESTful API/ JSON API/ Mobile backend API\n提供 RESTful API 的 Web 服务接收参数，解析，组合响应，并返回响应（通常是较少的文本）给用户。这是适合 Node 的理想情况，因为您可以构建它来处理数万条连接。它仍然不需要大量逻辑；它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的 API 需求。\n\n\n## 实时程序\nnode.js另一个很大的方面是你可以很轻松的开发软实时系统。这是指那些像twitter，聊天软件，体彩或实时通讯网络的接口, 游戏.\n\n## 单页的app\n如果你打算写一个AJAX操作非常多的单页面app（比如gmail），node.js是非常合适的。在极短的响应时间内处理大量请求的能力，不同的客户端共享像确认信息之类的东西，这些都让node.js成为那种在客户端做很多处理的web程序的很好的选择。\n\n## 流数据\n传统的web程序讲http请求和响应作为元事件处理。可事实是它们是流，很多很酷的node.js程序正是利用这个优点创建的。最牛的例子是实时解析上传文件，还在不同的数据层建立了代理。\n\n## 对unix工具的脚本化调用\nnode.js现在还很年轻，它正在试图为自己重新发明各种软件，不过更好的办法是深入到现有的广阔的命令行工具世界里。Node.js拥有产生数以千计的子进程的能力，同时可以把这些子进程的输出以流的方式处理，这让它成为那种和现有软件寻求平衡时的很好的选择\n\n## 电子游戏统计数据\n如果您在线玩过《使命召唤》这款游戏，当您查看游戏统计数据时，就会立即意识到一个问题：要生成那种级别的统计数据，必须跟踪海量信息。这样，如果有数百万玩家同时在线玩游戏，而且他们处于游戏中的不同位置，那么很快就会生成海量信息。Node 是这种场景的一种很好的解决方案，因为它能采集游戏生成的数据，对数据进行最少的合并，然后对数据进行排队，以便将它们写入数据库。使用整个服务器来跟踪玩家在游戏中发射了多少子弹看起来很愚蠢，如果您使用 Apache 这样的服务器，可能会 有一些有用的限制；但相反，如果您专门使用一个服务器来跟踪一个游戏的所有统计数据，就像使用运行 Node 的服务器所做的那样，那看起来似乎是一种明智之举。\n\n\n# 总结\nNode.js是一个年轻的平台, 不久就会迎来自己的成人礼(1.0大概会在2014年发布). Node有它自己的一些优点, 也有各种各样的问题. 但最让人欣慰的是越来越多的开发者加入进来, 促进Node.js不断完善, 应用到更多的领域当中. 即最重要的是它在不断的前进.\n\n关于Node.js到底适合应用于何种场景, 只要看看业界对Node.js的采用情况就知道了. LinkedIn, WaltmartLab, Yahoo, ebay, Paypal... 而且这是最可靠, 最及时的.\n\n[StrongLoop](http://strongloop.com/strongblog/) 的 In the loop 和 Mobile News Round-up会定期总结一些Node.js最新的应用情况, 另外 [Google news](https://www.google.com.hk/search?hl=en&gl=us&tbm=nws&authuser=0&q=nodejs&oq=nodejs&gs_l=news-cc.3..43j43i53.1468.2073.0.2456.6.4.0.2.0.1.148.288.2j2.4.0...0.0...1ac.1.BWenTbq3spg) 也是了解Node.js最新动态的好地方\n\n\n### 参考\n\n* [IBM--Node.js究竟是什么](http://www.ibm.com/developerworks/cn/opensource/os-nodejs/)\n* [How to decide when to use Node.js](http://blog.lovedan.cn/?p=266)\n* [推酷--Node.js 优缺点及适用场景讨论](http://www.tuicool.com/articles/nAjYNf)\n* [Felix Node.js guide--说服老板](http://nodeguide.com/convincing_the_boss.html)\n* [说服老板中文翻译](http://cssor.com/suitable-for-the-scene-of-nodejs-use.html) \n* [知乎--使用 Node.js 的优势和劣势都有哪些？有大公司用吗？](http://www.zhihu.com/question/19653241)\n* [知乎--Node.js 发展前景如何？适用于哪些场景？](http://www.zhihu.com/question/19587881)\n* [segmentfault--实例说明为什么应使用 Node.js](http://segmentfault.com/a/1190000000375619)\n* [为什么我要用 Node.js? 案例逐一介绍](http://developer.51cto.com/art/201312/425921.htm)\n* [stackoverflow--How to decide when to use NodeJS?](http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-nodejs)\n* [Node.js is taking over the Enterprise – whether you like it or not](http://blog.appfog.com/node-js-is-taking-over-the-enterprise-whether-you-like-it-or-not/)\n* [Infoq--廖恺谈NodeJS在淘宝的应用](http://www.infoq.com/cn/interviews/lk-nodejs-taobao)\n* [NodeJS与Rails何去何从？](http://tech.it168.com/a2011/0914/1245/000001245990.shtml)\n\n\n","slug":"node-yingyong-changjing","published":1,"updated":"2015-10-12T04:36:53.000Z","_id":"cifmere0s000pvs1m9eubwijq","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js Conference","date":"2013-11-19T07:43:52.000Z","_content":"Node.js诞生于2009年, 之后在2009, 2010年的[JSConf](http://jsconf.com/)上都安排了Node讲座. 之后Node发展如火如荼, 异常迅猛, 出现了Node专门的开发者会议, 如NodeConf, NodeSummit等.\n\n<!-- more -->\n\n# [NodeSummit](http://nodesummit.com/)\nNodeSummit是一个为期两天的Node峰会, 2013.12.3-2013.12.4在旧金山的Mission Bay会议中心举办. 来自各大公司的business leaders和technology experts会讨论Node.js在future of computing中的transformative 角色. 在大会上还会展示许多使用Node.js作为主要技术的创业公司.\n\n演讲嘉宾中既有Node项目lead Isaac Schlueter, 核心贡献者Bert Belder(StrongLoop)等技术人员, 还有许多科技公司管理人员, 具体演讲者信息可参看[网站](http://nodesummit.com/speakers/)\n\nNodeSummit Logo:\n\n![](http://nodesummit.com/wp-content/uploads/node-summit-dark.png)![](http://nodesummit.com/wp-content/uploads/node-summit-green.png)![](http://nodesummit.com/wp-content/uploads/node-summit-white.png)![](http://nodesummit.com/wp-content/uploads/node-summit-1color.png)\n\nNodeSummit Badge:\n\n![](http://nodesummit.com/wp-content/uploads/badge-green-plain.png)![](http://nodesummit.com/wp-content/uploads/badge-green-im-attending.png)![](http://nodesummit.com/wp-content/uploads/badge-green-see-me-speak-at.png)![](http://nodesummit.com/wp-content/uploads/badge-dark-see-me-speak-at.png)![](http://nodesummit.com/wp-content/uploads/badge-white-see-me-speak-at.png)\n\n\n# [NodeConf](http://www.nodeconf.com/)\nNodeConf是美国的Node.js会议\n\n# [中国JSConf](http://jsconf.cn/)\n国内由朴灵,Goddy Zhao等技术爱好者组织的12年的[沪JS](http://www.hujs.org/)和13年的[京JS](http://jingjs.org/)上都有许多关于Node的技术讲座, 为国内专注JavaScript的质量最高讲座, 有兴趣的同学可以参加下, 明年他们将会移师到杭州. \n\n# 其他\n[官方community](http://nodejs.org/community/)页面列有主要的Node.js大会. [Meatspace](http://nodemeatspace.com/)和[Lanyrd](http://lanyrd.com/topics/nodejs/)的Node.js专区(有许多Node.js大会视频,slide及相关资料)列有即将举办的Node.js大会\n\n* [NodeJS, Brescia](http://nodejsconf.it/)\n* [2012都柏林](http://www.nodedublin.com/)\n* [Nodepdx](http://nodepdx.org/)\n* [THE GREAT BRITISH NODE CONFERENCE](http://greatbritishnodeconf.co.uk/)\n\n有兴趣和条件的同学可以留意最近将要举办的大会, 或者留意当地的大会\n\n\n\n","source":"_posts/node-conf.md","raw":"title: Node.js Conference\ndate: 2013-11-19 15:43:52\ntags: conference\n---\nNode.js诞生于2009年, 之后在2009, 2010年的[JSConf](http://jsconf.com/)上都安排了Node讲座. 之后Node发展如火如荼, 异常迅猛, 出现了Node专门的开发者会议, 如NodeConf, NodeSummit等.\n\n<!-- more -->\n\n# [NodeSummit](http://nodesummit.com/)\nNodeSummit是一个为期两天的Node峰会, 2013.12.3-2013.12.4在旧金山的Mission Bay会议中心举办. 来自各大公司的business leaders和technology experts会讨论Node.js在future of computing中的transformative 角色. 在大会上还会展示许多使用Node.js作为主要技术的创业公司.\n\n演讲嘉宾中既有Node项目lead Isaac Schlueter, 核心贡献者Bert Belder(StrongLoop)等技术人员, 还有许多科技公司管理人员, 具体演讲者信息可参看[网站](http://nodesummit.com/speakers/)\n\nNodeSummit Logo:\n\n![](http://nodesummit.com/wp-content/uploads/node-summit-dark.png)![](http://nodesummit.com/wp-content/uploads/node-summit-green.png)![](http://nodesummit.com/wp-content/uploads/node-summit-white.png)![](http://nodesummit.com/wp-content/uploads/node-summit-1color.png)\n\nNodeSummit Badge:\n\n![](http://nodesummit.com/wp-content/uploads/badge-green-plain.png)![](http://nodesummit.com/wp-content/uploads/badge-green-im-attending.png)![](http://nodesummit.com/wp-content/uploads/badge-green-see-me-speak-at.png)![](http://nodesummit.com/wp-content/uploads/badge-dark-see-me-speak-at.png)![](http://nodesummit.com/wp-content/uploads/badge-white-see-me-speak-at.png)\n\n\n# [NodeConf](http://www.nodeconf.com/)\nNodeConf是美国的Node.js会议\n\n# [中国JSConf](http://jsconf.cn/)\n国内由朴灵,Goddy Zhao等技术爱好者组织的12年的[沪JS](http://www.hujs.org/)和13年的[京JS](http://jingjs.org/)上都有许多关于Node的技术讲座, 为国内专注JavaScript的质量最高讲座, 有兴趣的同学可以参加下, 明年他们将会移师到杭州. \n\n# 其他\n[官方community](http://nodejs.org/community/)页面列有主要的Node.js大会. [Meatspace](http://nodemeatspace.com/)和[Lanyrd](http://lanyrd.com/topics/nodejs/)的Node.js专区(有许多Node.js大会视频,slide及相关资料)列有即将举办的Node.js大会\n\n* [NodeJS, Brescia](http://nodejsconf.it/)\n* [2012都柏林](http://www.nodedublin.com/)\n* [Nodepdx](http://nodepdx.org/)\n* [THE GREAT BRITISH NODE CONFERENCE](http://greatbritishnodeconf.co.uk/)\n\n有兴趣和条件的同学可以留意最近将要举办的大会, 或者留意当地的大会\n\n\n\n","slug":"node-conf","published":1,"updated":"2015-10-12T04:36:58.000Z","_id":"cifmere0v000svs1mqmyp7181","comments":1,"layout":"post","photos":[],"link":""},{"title":"node-books","date":"2013-11-18T06:19:32.000Z","_content":"最近朴灵的<<深入浅出Node.js>>终于出版了, 这本书是广大N粉翘首以待的大作, 一经推出大家纷纷购买, 在微博上刮起了一阵Node热. 这里给大家推荐几本不错的Node书籍.\n\n## [深入浅出Node.js](http://book.douban.com/subject/25768396/)\n相信大家对朴灵在InfoQ上的深入浅出系列非常熟悉,\n该小书成为许多Node开发者的入门学习教材, 经过作者长期深入写作,\n一本Node.js权威大作终于出炉了. Node.js深入浅出从最重要的几个方面深入介绍了\nNode.js, 包括内部实现机制, 模块系统, 事件机制, Buffer, 网络应用, 实际部署等\n\n<!-- more -->\n\n该书介绍了Node深层内容, 对于初学Node者可能有点吃力, 但如果你已经了解Node,\n写过Node应用, 推荐再看此书相信一定会给你带来不一样的内容\n\n## [Node.js中文指南](http://book.douban.com/subject/10789820/)\n该书是国内第一本Node原创书籍, 出自郭家宝(BYVoid)同学之手, 郭家宝同学是清华的高材生, 在暑假期间\n因为个人爱好写了这本中文指南, 该书属于Node入门书籍, 介绍内容比较简单, 而且因为出版比较早书中部分内容现在已经\n过时, 不过还是建议大家看下该书, BYVoid在网络上是一个大牛, 主张废除简化字, 阿里2013 A star首人, 实习经历\nMicrosoft->Google->Facebook, 目前还未毕业.\n\n## [了不起的Node.js](http://book.douban.com/subject/25767596/)\n了不起的Node.js是Goddy Zhao同学翻译的 Smeshing Node.js一书, 最近刚刚翻译出版, 书中介绍Js,及Node.js知识非常详细\n也是一本Node.js大作, 该书英文原版可以到作者整理的Node.js书籍[Github项目](http://thepana.com/node-books)下载 \n\n## [Node.js入门经典](http://book.douban.com/subject/23780706/)\n\n## Node.js in action\n这是一本较早关于Node.js的书籍, 在express网站有推荐\n\n## 其他\n作者收集了一些Node书籍, 包括Node: up and running, Node web development, Professional node.js\n具体内容可到[这里](http://thepana.com/node-books)查看和下载\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/node-books.md","raw":"title: node-books\ndate: 2013-11-18 14:19:32\ntags:\n---\n最近朴灵的<<深入浅出Node.js>>终于出版了, 这本书是广大N粉翘首以待的大作, 一经推出大家纷纷购买, 在微博上刮起了一阵Node热. 这里给大家推荐几本不错的Node书籍.\n\n## [深入浅出Node.js](http://book.douban.com/subject/25768396/)\n相信大家对朴灵在InfoQ上的深入浅出系列非常熟悉,\n该小书成为许多Node开发者的入门学习教材, 经过作者长期深入写作,\n一本Node.js权威大作终于出炉了. Node.js深入浅出从最重要的几个方面深入介绍了\nNode.js, 包括内部实现机制, 模块系统, 事件机制, Buffer, 网络应用, 实际部署等\n\n<!-- more -->\n\n该书介绍了Node深层内容, 对于初学Node者可能有点吃力, 但如果你已经了解Node,\n写过Node应用, 推荐再看此书相信一定会给你带来不一样的内容\n\n## [Node.js中文指南](http://book.douban.com/subject/10789820/)\n该书是国内第一本Node原创书籍, 出自郭家宝(BYVoid)同学之手, 郭家宝同学是清华的高材生, 在暑假期间\n因为个人爱好写了这本中文指南, 该书属于Node入门书籍, 介绍内容比较简单, 而且因为出版比较早书中部分内容现在已经\n过时, 不过还是建议大家看下该书, BYVoid在网络上是一个大牛, 主张废除简化字, 阿里2013 A star首人, 实习经历\nMicrosoft->Google->Facebook, 目前还未毕业.\n\n## [了不起的Node.js](http://book.douban.com/subject/25767596/)\n了不起的Node.js是Goddy Zhao同学翻译的 Smeshing Node.js一书, 最近刚刚翻译出版, 书中介绍Js,及Node.js知识非常详细\n也是一本Node.js大作, 该书英文原版可以到作者整理的Node.js书籍[Github项目](http://thepana.com/node-books)下载 \n\n## [Node.js入门经典](http://book.douban.com/subject/23780706/)\n\n## Node.js in action\n这是一本较早关于Node.js的书籍, 在express网站有推荐\n\n## 其他\n作者收集了一些Node书籍, 包括Node: up and running, Node web development, Professional node.js\n具体内容可到[这里](http://thepana.com/node-books)查看和下载\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"node-books","published":1,"updated":"2015-10-12T04:37:05.000Z","_id":"cifmere10000vvs1mn5q6sjtp","comments":1,"layout":"post","photos":[],"link":""},{"title":"NKO","date":"2013-11-19T07:01:21.000Z","_content":"![NKO logo](http://nodeknockout.com/designs/exports/png/nko-logo-3700x1000.png)  \n[Node Knockout](http://nodeknockout.com/) 是全球最大的Node.js编程比赛.NKO是为期48小时, 来自全球竞争者参与的在线虚拟Node.js黑客马拉松编程比赛.2013年比赛已于UTC 2013.11.9-2013.9.11举行, 比赛最终圣者由裁判和公共投票决定, 最终胜出的项目可到NKO网站查看. NKO举办灵感来源于[Rails Rumble](http://railsrumble.com/). NKO始于2010年, 今年是第四次举办.\n\n<!-- more -->\n\n## Winners\nNKO最终获胜作品已评选出来, 无论是对技术的运用, 设计, 实用性都比往届大大提高, 虽然离大规模产品化部署采用还有不少距离, 但已经有了一个很好得开始.\n\n### [Rikoru](http://rikoru.2013.nodeknockout.com/) (TEAM)\n实时多人记忆游戏  \n![](http://beta.url2png.com/v6/P50A14826D8629/57f1acc9d943dc7c5210f1070e3ce5c1/png/?url=http%3A%2F%2Frikoru.2013.nodeknockout.com&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-10T22%3A33%3A40.939Z)\n\n### [Imdex](http://srobin.2013.nodeknockout.com/) (SOLO)\nOCR-Indexed图片搜索引擎, 能搜索图片中的文本  \n![](http://nodeknockout.s3.amazonaws.com/screenshots/imdex.png)\n\n### [Tidbit](http://shoop-team.2013.nodeknockout.com/) (INNOVATION)\n可嵌入JS脚本, 能够通过网站用户的电脑挖矿为你赚钱  \n![](http://beta.url2png.com/v6/P50A14826D8629/18372b979f6208d89a3b97c5ffe757ca/png/?url=http%3A%2F%2Fshoop-team.2013.nodeknockout.com&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-10T23%3A48%3A18.930Z)\n\n### [Zoom the Balloon](http://theteam.2013.nodeknockout.com/) (DESIGN)\n有趣的游戏, 客户端应用  \n![](http://beta.url2png.com/v6/P50A14826D8629/dc0c53c55a1575fb2321a48199880b02/png/?url=http%3A%2F%2Ftheteam.2013.nodeknockout.com&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-11T00%3A07%3A34.366Z)\n\n### [Video Funhouse](http://devcomo.2013.nodeknockout.com/) (UTILITY/FUN)\n完全运行于浏览器的视频转换工具  \n![](http://beta.url2png.com/v6/P50A14826D8629/0ffa7bb54aba0c39e44138f2ccd1d29b/png/?url=http%3A%2F%2Fdevcomo.2013.nodeknockout.com%2F&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-11T00%3A02%3A35.928Z)\n\n### [Harp Hook](http://iceddev.2013.nodeknockout.com/) (COMPLETENESS)\n基于Harp的Github page自动编译工具  \n![](http://beta.url2png.com/v6/P50A14826D8629/216b97a9f5a358405bcc075e003673f1/png/?url=http%3A%2F%2Ficeddev.2013.nodeknockout.com%2F&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-10T23%3A54%3A37.789Z)\n\n### [Hub](http://hub.2013.nodeknockout.com/) (POPULARITY)\nGithub + Chat = :D  \n![](http://beta.url2png.com/v6/P50A14826D8629/79a81796ed667b3ccb2fa4e365e75eed/png/?url=http%3A%2F%2Fhub.2013.nodeknockout.com&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-10T23%3A46%3A19.016Z)\n\n### 其他\n除了这些winner之外, 还有好多有趣, 好玩的作品比如基于npm的全新系统[NodeOS](http://nodeknockout.com/teams/process-nexttick), 感兴趣得同学可以到官网去逛一逛.\n\n想参加明年比赛的同学可以订阅NKO的邮件通知,或follow NKO的twitter @node_knockout\n","source":"_posts/nko.md","raw":"title: NKO\ndate: 2013-11-19 15:01:21\ntags: Competition\n---\n![NKO logo](http://nodeknockout.com/designs/exports/png/nko-logo-3700x1000.png)  \n[Node Knockout](http://nodeknockout.com/) 是全球最大的Node.js编程比赛.NKO是为期48小时, 来自全球竞争者参与的在线虚拟Node.js黑客马拉松编程比赛.2013年比赛已于UTC 2013.11.9-2013.9.11举行, 比赛最终圣者由裁判和公共投票决定, 最终胜出的项目可到NKO网站查看. NKO举办灵感来源于[Rails Rumble](http://railsrumble.com/). NKO始于2010年, 今年是第四次举办.\n\n<!-- more -->\n\n## Winners\nNKO最终获胜作品已评选出来, 无论是对技术的运用, 设计, 实用性都比往届大大提高, 虽然离大规模产品化部署采用还有不少距离, 但已经有了一个很好得开始.\n\n### [Rikoru](http://rikoru.2013.nodeknockout.com/) (TEAM)\n实时多人记忆游戏  \n![](http://beta.url2png.com/v6/P50A14826D8629/57f1acc9d943dc7c5210f1070e3ce5c1/png/?url=http%3A%2F%2Frikoru.2013.nodeknockout.com&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-10T22%3A33%3A40.939Z)\n\n### [Imdex](http://srobin.2013.nodeknockout.com/) (SOLO)\nOCR-Indexed图片搜索引擎, 能搜索图片中的文本  \n![](http://nodeknockout.s3.amazonaws.com/screenshots/imdex.png)\n\n### [Tidbit](http://shoop-team.2013.nodeknockout.com/) (INNOVATION)\n可嵌入JS脚本, 能够通过网站用户的电脑挖矿为你赚钱  \n![](http://beta.url2png.com/v6/P50A14826D8629/18372b979f6208d89a3b97c5ffe757ca/png/?url=http%3A%2F%2Fshoop-team.2013.nodeknockout.com&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-10T23%3A48%3A18.930Z)\n\n### [Zoom the Balloon](http://theteam.2013.nodeknockout.com/) (DESIGN)\n有趣的游戏, 客户端应用  \n![](http://beta.url2png.com/v6/P50A14826D8629/dc0c53c55a1575fb2321a48199880b02/png/?url=http%3A%2F%2Ftheteam.2013.nodeknockout.com&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-11T00%3A07%3A34.366Z)\n\n### [Video Funhouse](http://devcomo.2013.nodeknockout.com/) (UTILITY/FUN)\n完全运行于浏览器的视频转换工具  \n![](http://beta.url2png.com/v6/P50A14826D8629/0ffa7bb54aba0c39e44138f2ccd1d29b/png/?url=http%3A%2F%2Fdevcomo.2013.nodeknockout.com%2F&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-11T00%3A02%3A35.928Z)\n\n### [Harp Hook](http://iceddev.2013.nodeknockout.com/) (COMPLETENESS)\n基于Harp的Github page自动编译工具  \n![](http://beta.url2png.com/v6/P50A14826D8629/216b97a9f5a358405bcc075e003673f1/png/?url=http%3A%2F%2Ficeddev.2013.nodeknockout.com%2F&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-10T23%3A54%3A37.789Z)\n\n### [Hub](http://hub.2013.nodeknockout.com/) (POPULARITY)\nGithub + Chat = :D  \n![](http://beta.url2png.com/v6/P50A14826D8629/79a81796ed667b3ccb2fa4e365e75eed/png/?url=http%3A%2F%2Fhub.2013.nodeknockout.com&viewport=1024x595&thumbnail_max_width=320&unique=2013-11-10T23%3A46%3A19.016Z)\n\n### 其他\n除了这些winner之外, 还有好多有趣, 好玩的作品比如基于npm的全新系统[NodeOS](http://nodeknockout.com/teams/process-nexttick), 感兴趣得同学可以到官网去逛一逛.\n\n想参加明年比赛的同学可以订阅NKO的邮件通知,或follow NKO的twitter @node_knockout\n","slug":"nko","published":1,"updated":"2015-10-12T04:37:09.000Z","_id":"cifmere12000wvs1m1ya9zaip","comments":1,"layout":"post","photos":[],"link":""},{"title":"N的Blog&CMS平台","date":"2013-09-28T13:15:20.000Z","_content":"随着N的不断成熟, 诞生了不少的博客及CMS平台. 本文将对目前比较优秀的博客, CMS平台进行简单介绍\n\n# Blog\n\n## [Ghost](http://ghost.org)\nGhost是使用Node.js开发的专注博客的平台. 2013.10.14 在Github上公开源代码(版本0.33).\n\n<!-- more -->\n\n### Ghost -- Free. Open. Simple. is a platform dedicated to one thing: Publishing. \nGhost设计优美, 支持高度自定义, 完全开源. Ghost提供了让大家轻松, 愉快编辑发布博客的工具. Ghost简单, 优雅. 让用户花费更少的时间搭建博客, 更多的时间写博客.\n\n* 博客内容更容易发现\n* 最好的Web 写作体验(Markdown preview)\n* 一个革命性的控制台(Ghost将博客所有的重要数据访问量, 订阅量, 新闻, 内容表现集中到一起显示, 并且支持自定义)\n* 完全支持自定义(主题, 插件)\n* 完全支持移动设备(手机, 平板)\n\nJohn O'Nolan是Wordpress组员的重要成员, 曾为Microsoft, Nokia, easyJet 等大公司搭建blog是博客的资深开发者. 现有的博客平台经过十多年的发展基本已经定型, 像WordPress这样成熟的博客平台,功能众多, 体积庞大, 主要被用于CMS使用. John O'Nolan 决定开发一个专注于博客的, 适用移动平台的博客系统,于是就有了Ghost系统.\n\nGhost重要时刻:\n\n* 2012.10.1 Ghost 被提出\n* 2013.4.29 Ghost 在Kickstarter成功筹集开发资金\n* 2013.9.20 Ghost 0.3版向backer发布\n* 2013.10.14 Ghost 0.3.2正式开放并在Github开源\n\n\n## [Hexo](http://zespia.tw/hexo/)\nA fast, simple & powerful blog framework,\npowered by Node.js.  \nHexo是一个静态博客平台, 类似Ruby的jekyll, 可以将使用Markdown撰写的文章生成静态网站(貌似Hexo是台湾的coder开发的).\n\n* 超级快 (使用Node.js开发, 多线程生成静态网站, Blazing Fast)\n* easy write (支持GitHub Flavored Markdown 和所有 Octopress 插件, 高度兼容Jekyll/Octopress )\n* 可扩展 (支持 EJS, Swig & Stylus可扩展支持Haml, Jade, Less )\n* 多款简洁漂亮主题, 及插件\n\n\n\n## [Poet](http://jsantell.github.io/poet/)\nPoet是一个漂亮的基于Node.js的博客生成器. 能生成路由, 渲染markdown/jade/其他post. 速度快\n\n\n# CMS\n由于没有实际使用过以下CMS系统所以具体功能特点大家参考官网.\n\n* [Caplipso](http://jsantell.github.io/poet/)\n* [Hatch](http://hatchjs.com/)\n* [nodize](http://nodize.com/)\n* [InvaNode CMS](http://www.invanode.org/)\n* [nodecms](http://nodecms.org/en/)\n\n\n\n相信随着Node.js的不断成熟, 会有越来越多想Ghost优秀的平台,项目涌现出来, 推动我们的生活.\n\n\n","source":"_posts/n_blog_platform.md","raw":"title: N的Blog&CMS平台\ndate: 2013-09-28 21:15:20\ntags: blog&cms\n---\n随着N的不断成熟, 诞生了不少的博客及CMS平台. 本文将对目前比较优秀的博客, CMS平台进行简单介绍\n\n# Blog\n\n## [Ghost](http://ghost.org)\nGhost是使用Node.js开发的专注博客的平台. 2013.10.14 在Github上公开源代码(版本0.33).\n\n<!-- more -->\n\n### Ghost -- Free. Open. Simple. is a platform dedicated to one thing: Publishing. \nGhost设计优美, 支持高度自定义, 完全开源. Ghost提供了让大家轻松, 愉快编辑发布博客的工具. Ghost简单, 优雅. 让用户花费更少的时间搭建博客, 更多的时间写博客.\n\n* 博客内容更容易发现\n* 最好的Web 写作体验(Markdown preview)\n* 一个革命性的控制台(Ghost将博客所有的重要数据访问量, 订阅量, 新闻, 内容表现集中到一起显示, 并且支持自定义)\n* 完全支持自定义(主题, 插件)\n* 完全支持移动设备(手机, 平板)\n\nJohn O'Nolan是Wordpress组员的重要成员, 曾为Microsoft, Nokia, easyJet 等大公司搭建blog是博客的资深开发者. 现有的博客平台经过十多年的发展基本已经定型, 像WordPress这样成熟的博客平台,功能众多, 体积庞大, 主要被用于CMS使用. John O'Nolan 决定开发一个专注于博客的, 适用移动平台的博客系统,于是就有了Ghost系统.\n\nGhost重要时刻:\n\n* 2012.10.1 Ghost 被提出\n* 2013.4.29 Ghost 在Kickstarter成功筹集开发资金\n* 2013.9.20 Ghost 0.3版向backer发布\n* 2013.10.14 Ghost 0.3.2正式开放并在Github开源\n\n\n## [Hexo](http://zespia.tw/hexo/)\nA fast, simple & powerful blog framework,\npowered by Node.js.  \nHexo是一个静态博客平台, 类似Ruby的jekyll, 可以将使用Markdown撰写的文章生成静态网站(貌似Hexo是台湾的coder开发的).\n\n* 超级快 (使用Node.js开发, 多线程生成静态网站, Blazing Fast)\n* easy write (支持GitHub Flavored Markdown 和所有 Octopress 插件, 高度兼容Jekyll/Octopress )\n* 可扩展 (支持 EJS, Swig & Stylus可扩展支持Haml, Jade, Less )\n* 多款简洁漂亮主题, 及插件\n\n\n\n## [Poet](http://jsantell.github.io/poet/)\nPoet是一个漂亮的基于Node.js的博客生成器. 能生成路由, 渲染markdown/jade/其他post. 速度快\n\n\n# CMS\n由于没有实际使用过以下CMS系统所以具体功能特点大家参考官网.\n\n* [Caplipso](http://jsantell.github.io/poet/)\n* [Hatch](http://hatchjs.com/)\n* [nodize](http://nodize.com/)\n* [InvaNode CMS](http://www.invanode.org/)\n* [nodecms](http://nodecms.org/en/)\n\n\n\n相信随着Node.js的不断成熟, 会有越来越多想Ghost优秀的平台,项目涌现出来, 推动我们的生活.\n\n\n","slug":"n_blog_platform","published":1,"updated":"2015-10-12T04:37:14.000Z","_id":"cifmere14000zvs1mj253k688","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js模块机制","date":"2013-10-25T02:32:52.000Z","_content":"Node.js的模块机制非常简单: 文件,模块一一对应. Node.js模块机制遵循[CommonJS](http://www.commonjs.org)规范(CommonJS是一套后端JS规范,具体参看官网). Node.js自身实现了require方法用于引入模块, NPM基于CommonJS的包规范, 实现了依赖管理和模块自动安装等功能.\n\n<!-- more -->\n\n## Node.js模块机制\n\n### 简单例子\n`foo.js` 加载模块 同路径下的 `circle.js`\n\nfoo.js\n\n```\nvar circle = require('./circle.js');\nconsole.log( 'The area of a circle of radius 4 is ' + circle.area(4));\n```\ncircle.js\n```\nvar PI = Math.PI;\n\nexports.area = function (r) {\n  return PI * r * r;\n};\n\nexports.circumference = function (r) {\n  return 2 * PI * r;\n};\n```\n在模块中想要输出内容(方法, 对象等), 直接加到 `exports` 对象即可.\n\n`exports`本质是 `module.exports`的引用, 目的是 making it suitable for augmentation only \n\n如果想输出单个 item 例如constructor, 需要直接使用 module.exports\n    \n    module.exports = MyConstructor;\n\n模块的local变量都是私有的\n\n模块系统是在 `require(\"module\")` 模块中实现\n\n### 循环引用\n为了避免循环引用造成infinite loop, 一个模块可能在没有完全执行的情况下返回, 具体情况参看官方解释.\n如果在开发中遇到了循环引用, 注意根据这种机制组织代码.\n\n### 核心模块\nNode.js包含几个核心模块(原生模块), 这些模块被直接编译到二进制代码中, 位于源代码的 `/lib/` 文件夹中.\n这些模块相对于同名的第三方模块有最高优先级.\n\n### File Modules\n如果require方法没有找到跟模块同名的文件, 它会继续寻找以下扩展名的文件 `.js`, `.json`, `.node`\n`.js`文件被解析为Javascript代码, `.json`文件被解析成json对象, `.node`文件则被当做编译的addon 模块, 使用\n`dlopen`打开\n\n如果模块以`/`开头则按绝对路径寻找模块 以`./`和`../`开头按相对路径寻找. 其他情况按核心模块或第三方模块寻找.\n\n如果找不到则会抛出`code`属性为`MODULE_NOT_FOUND`的异常\n\n### Loading from `node_modules`文件夹\n如果需要载入的模块不是core模块, 也不是路径模块, 则会从node_modules文件夹中寻找, 寻找规则为从当前路径同级的\n`node_modules`开始寻找, 逐级向父路径寻找\n例如 `'/home/ry/projects/foo.js'` 调用了 `require('bar.js')` 则寻找路径为:\n\n* /home/ry/projects/node_modules/bar.js\n* /home/ry/node_modules/bar.js\n* /home/node_modules/bar.js\n* /node_modules/bar.js\n\n### 文件夹作为模块\n使用文件夹包含程序或库的代码,然后给出单一的使用入口是很好的编程方法, Node也支持文件夹作为模块, 有三种方式可以实现:\n第一种是创建一个 `package.json`文件, 并指定 `main` 模块\n```\n{ \n    \"name\" : \"some-library\",\n    \"main\" : \"./lib/some-library.js\" \n}\n```\n\n如果没有package.json则node会尝试加载 `index.js` 或 `index.node` 文件\n\n### Caching\n模块在加载之后会被缓存下来. 即多次`require('foo')`调用得到的是相同对象. \n\n这样多次模块调用, 但模块中的代码只会被执行一次. 该特点使得未完成的模块被返回, 解决循环引用问题.\n\n如果需要模块代码执行多次, 可以export一个方法, 然后多次调用即可.\n\n\n### Module caching警告\n参看[文档](http://nodejs.org/api/modules.html#modules_module_caching_caveats)\n\n### module Object\nmodule不是真正的全局变量,而是一个所有module都包含的变量即module-global, 是代表当前module对象的引用\n\n#### module.exports\nmodule.exports是module系统创建的, 有时用户想要自己使用某个类的实例自己赋值, 可以使用 \n`module.exports = new ClassName()`实现\n注意该操作必须立刻返回, 不能再回调中完成\n\n#### module.require(id)\n#### module.id\n#### module.filename\n#### module.loaded\n#### module.parent\n#### module.children\n\n### 模块的整体加载逻辑\n\n### 从global folder加载模块\n如果系统设置了`NODE_PATH`环境变量(冒号分割的路径), 则这些路径会被加到module的搜索路径当中.\n除此之外, 由于一些历史原因, 还会搜索如下路径\n\n* 1: $HOME/.node_modules\n* 2: $HOME/.node_libraries\n* 3: $PREFIX/lib/node\n\n$HOME是用户的home路径. $PREFIX是node配置的`node_prefix`\n\n强烈建议将模块放到本地的`node_modules`中, 这样更快, 更可靠\n\n### Accessing the main module\n如果一个文件直接从Node执行, `require.main`会被设置为它的`module`.\n因此可以通过`require.main === module`判断文件是否是直接运行的\n\n所以可以通过  `require.main.filename`得到当前程序的入口\n\n\n\n### 总结\n以上为模块的加载详细机制, 具体参看[官方文档](http://nodejs.org/api/modules.html), 以上内容过于全面琐碎. 想看精简总结\n版可参看朴灵大拿的[文章](http://www.infoq.com/cn/articles/nodejs-module-mechanism)\n\n\n\n\n\n## NPM - Node包管理工具\n前面提到，JavaScript缺少包结构。CommonJS致力于改变这种现状，于是定义了包的结构规范（http://wiki.commonjs.org/wiki/Packages/1.0 ）。而NPM的出现则是为了在CommonJS规范的基础上，实现解决包的安装卸载，依赖管理，版本管理等问题。require的查找机制明了之后，我们来看一下包的细节\n\n一个符合CommonJS规范的包应该是如下这种结构：\n\n* 一个package.json文件应该存在于包顶级目录下\n* 二进制文件应该包含在bin目录下。\n* JavaScript代码应该包含在lib目录下。\n* 文档应该在doc目录下。\n* 单元测试应该在test目录下。\n\nNPM作为Node.js的包管理工具, 能够非常方便的发布, 安装, 卸载, 更新, 管理依赖. 大大方便的Node代码的共享和共用, 作为Node.js生态非常重要的一部分, 大大促进了Node.js发展, 目前已经被集成到了Node.js安装包中, Node环境装好之后即可使用NPM安装第三方包.\n\n关于NPM包的开发和发布之后会详细介绍, 或可参看其他博客, 文章.\n\n## 优缺点, 包现状\n\n## 其他机制\n\n* 前段包管理机制 [seajs](http://seajs.com/)\n* AMD机制\n\n## 参考\n\n* [Module API](http://nodejs.org/api/modules.html) -- 官方文档\n* [深入Node.js模块机制](http://www.infoq.com/cn/articles/nodejs-module-mechanism) -- 朴灵\n* [Nodejs模块开发及发布详解](NodeJS 模块开发及发布详解) -- ElmerZhang\n","source":"_posts/module-machanism.md","raw":"title: Node.js模块机制\ndate: 2013-10-25 10:32:52\ntags: Module\n---\nNode.js的模块机制非常简单: 文件,模块一一对应. Node.js模块机制遵循[CommonJS](http://www.commonjs.org)规范(CommonJS是一套后端JS规范,具体参看官网). Node.js自身实现了require方法用于引入模块, NPM基于CommonJS的包规范, 实现了依赖管理和模块自动安装等功能.\n\n<!-- more -->\n\n## Node.js模块机制\n\n### 简单例子\n`foo.js` 加载模块 同路径下的 `circle.js`\n\nfoo.js\n\n```\nvar circle = require('./circle.js');\nconsole.log( 'The area of a circle of radius 4 is ' + circle.area(4));\n```\ncircle.js\n```\nvar PI = Math.PI;\n\nexports.area = function (r) {\n  return PI * r * r;\n};\n\nexports.circumference = function (r) {\n  return 2 * PI * r;\n};\n```\n在模块中想要输出内容(方法, 对象等), 直接加到 `exports` 对象即可.\n\n`exports`本质是 `module.exports`的引用, 目的是 making it suitable for augmentation only \n\n如果想输出单个 item 例如constructor, 需要直接使用 module.exports\n    \n    module.exports = MyConstructor;\n\n模块的local变量都是私有的\n\n模块系统是在 `require(\"module\")` 模块中实现\n\n### 循环引用\n为了避免循环引用造成infinite loop, 一个模块可能在没有完全执行的情况下返回, 具体情况参看官方解释.\n如果在开发中遇到了循环引用, 注意根据这种机制组织代码.\n\n### 核心模块\nNode.js包含几个核心模块(原生模块), 这些模块被直接编译到二进制代码中, 位于源代码的 `/lib/` 文件夹中.\n这些模块相对于同名的第三方模块有最高优先级.\n\n### File Modules\n如果require方法没有找到跟模块同名的文件, 它会继续寻找以下扩展名的文件 `.js`, `.json`, `.node`\n`.js`文件被解析为Javascript代码, `.json`文件被解析成json对象, `.node`文件则被当做编译的addon 模块, 使用\n`dlopen`打开\n\n如果模块以`/`开头则按绝对路径寻找模块 以`./`和`../`开头按相对路径寻找. 其他情况按核心模块或第三方模块寻找.\n\n如果找不到则会抛出`code`属性为`MODULE_NOT_FOUND`的异常\n\n### Loading from `node_modules`文件夹\n如果需要载入的模块不是core模块, 也不是路径模块, 则会从node_modules文件夹中寻找, 寻找规则为从当前路径同级的\n`node_modules`开始寻找, 逐级向父路径寻找\n例如 `'/home/ry/projects/foo.js'` 调用了 `require('bar.js')` 则寻找路径为:\n\n* /home/ry/projects/node_modules/bar.js\n* /home/ry/node_modules/bar.js\n* /home/node_modules/bar.js\n* /node_modules/bar.js\n\n### 文件夹作为模块\n使用文件夹包含程序或库的代码,然后给出单一的使用入口是很好的编程方法, Node也支持文件夹作为模块, 有三种方式可以实现:\n第一种是创建一个 `package.json`文件, 并指定 `main` 模块\n```\n{ \n    \"name\" : \"some-library\",\n    \"main\" : \"./lib/some-library.js\" \n}\n```\n\n如果没有package.json则node会尝试加载 `index.js` 或 `index.node` 文件\n\n### Caching\n模块在加载之后会被缓存下来. 即多次`require('foo')`调用得到的是相同对象. \n\n这样多次模块调用, 但模块中的代码只会被执行一次. 该特点使得未完成的模块被返回, 解决循环引用问题.\n\n如果需要模块代码执行多次, 可以export一个方法, 然后多次调用即可.\n\n\n### Module caching警告\n参看[文档](http://nodejs.org/api/modules.html#modules_module_caching_caveats)\n\n### module Object\nmodule不是真正的全局变量,而是一个所有module都包含的变量即module-global, 是代表当前module对象的引用\n\n#### module.exports\nmodule.exports是module系统创建的, 有时用户想要自己使用某个类的实例自己赋值, 可以使用 \n`module.exports = new ClassName()`实现\n注意该操作必须立刻返回, 不能再回调中完成\n\n#### module.require(id)\n#### module.id\n#### module.filename\n#### module.loaded\n#### module.parent\n#### module.children\n\n### 模块的整体加载逻辑\n\n### 从global folder加载模块\n如果系统设置了`NODE_PATH`环境变量(冒号分割的路径), 则这些路径会被加到module的搜索路径当中.\n除此之外, 由于一些历史原因, 还会搜索如下路径\n\n* 1: $HOME/.node_modules\n* 2: $HOME/.node_libraries\n* 3: $PREFIX/lib/node\n\n$HOME是用户的home路径. $PREFIX是node配置的`node_prefix`\n\n强烈建议将模块放到本地的`node_modules`中, 这样更快, 更可靠\n\n### Accessing the main module\n如果一个文件直接从Node执行, `require.main`会被设置为它的`module`.\n因此可以通过`require.main === module`判断文件是否是直接运行的\n\n所以可以通过  `require.main.filename`得到当前程序的入口\n\n\n\n### 总结\n以上为模块的加载详细机制, 具体参看[官方文档](http://nodejs.org/api/modules.html), 以上内容过于全面琐碎. 想看精简总结\n版可参看朴灵大拿的[文章](http://www.infoq.com/cn/articles/nodejs-module-mechanism)\n\n\n\n\n\n## NPM - Node包管理工具\n前面提到，JavaScript缺少包结构。CommonJS致力于改变这种现状，于是定义了包的结构规范（http://wiki.commonjs.org/wiki/Packages/1.0 ）。而NPM的出现则是为了在CommonJS规范的基础上，实现解决包的安装卸载，依赖管理，版本管理等问题。require的查找机制明了之后，我们来看一下包的细节\n\n一个符合CommonJS规范的包应该是如下这种结构：\n\n* 一个package.json文件应该存在于包顶级目录下\n* 二进制文件应该包含在bin目录下。\n* JavaScript代码应该包含在lib目录下。\n* 文档应该在doc目录下。\n* 单元测试应该在test目录下。\n\nNPM作为Node.js的包管理工具, 能够非常方便的发布, 安装, 卸载, 更新, 管理依赖. 大大方便的Node代码的共享和共用, 作为Node.js生态非常重要的一部分, 大大促进了Node.js发展, 目前已经被集成到了Node.js安装包中, Node环境装好之后即可使用NPM安装第三方包.\n\n关于NPM包的开发和发布之后会详细介绍, 或可参看其他博客, 文章.\n\n## 优缺点, 包现状\n\n## 其他机制\n\n* 前段包管理机制 [seajs](http://seajs.com/)\n* AMD机制\n\n## 参考\n\n* [Module API](http://nodejs.org/api/modules.html) -- 官方文档\n* [深入Node.js模块机制](http://www.infoq.com/cn/articles/nodejs-module-mechanism) -- 朴灵\n* [Nodejs模块开发及发布详解](NodeJS 模块开发及发布详解) -- ElmerZhang\n","slug":"module-machanism","published":1,"updated":"2015-10-12T04:37:25.000Z","_id":"cifmere170012vs1m5nkj473o","comments":1,"layout":"post","photos":[],"link":""},{"title":"Hello World","date":"2013-09-22T04:19:44.000Z","_content":"几乎所有语言和平台都有自己的Hello World. 这里介绍如何运行N的Hello World.\n\n# Simple Version\n\n\n在终端输入`node`回车打开N的[REPL](http://nodejs.org/api/repl.html), 输入以下代码:\n  \n    console.log('Hello World!')\n\n回车即可看到输出结果: \"Hello World\".\n\n还可将以上代码保存成文件 `example.js`, 然后执行`node example.js`, 可看到同样的结果.\n\n<!-- more -->\n\n# HTTP&TCP Version\nN最频繁的使用场合是Web或TCP Server开发\n\n### HTTP Server\n返回 Hello World 的 Web Server.\n```\nvar http = require('http');\n\nhttp.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\\n');\n}).listen(1337, '127.0.0.1');\n\nconsole.log('Server running at http://127.0.0.1:1337/');\n```\n\n执行`node example.js`启动服务, 使用浏览器访问 http://127.0.0.1:1337 \n\n### TCP server\n将收到的请求内容原样返回的 TCP Server\n```\nvar net = require('net');\n\nvar server = net.createServer(function (socket) {\n  socket.write('Echo server\\r\\n');\n  socket.pipe(socket);\n});\n\nserver.listen(1337, '127.0.0.1');\n```\n\n执行`node example.js`启动服务, 然后TCP连接到 127.0.0.1:1337, 即可看到效果.\n\n# So Simple\nN的Hello World就是这么Simple. N能够实现的功能远远不止这些, 想要体会更多N的精彩之处, 赶快学习N的更多内容吧.\n\n\n","source":"_posts/hello_world.md","raw":"title: Hello World\ndate: 2013-09-22 12:19:44\ntags: HelloWorld\n---\n几乎所有语言和平台都有自己的Hello World. 这里介绍如何运行N的Hello World.\n\n# Simple Version\n\n\n在终端输入`node`回车打开N的[REPL](http://nodejs.org/api/repl.html), 输入以下代码:\n  \n    console.log('Hello World!')\n\n回车即可看到输出结果: \"Hello World\".\n\n还可将以上代码保存成文件 `example.js`, 然后执行`node example.js`, 可看到同样的结果.\n\n<!-- more -->\n\n# HTTP&TCP Version\nN最频繁的使用场合是Web或TCP Server开发\n\n### HTTP Server\n返回 Hello World 的 Web Server.\n```\nvar http = require('http');\n\nhttp.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\\n');\n}).listen(1337, '127.0.0.1');\n\nconsole.log('Server running at http://127.0.0.1:1337/');\n```\n\n执行`node example.js`启动服务, 使用浏览器访问 http://127.0.0.1:1337 \n\n### TCP server\n将收到的请求内容原样返回的 TCP Server\n```\nvar net = require('net');\n\nvar server = net.createServer(function (socket) {\n  socket.write('Echo server\\r\\n');\n  socket.pipe(socket);\n});\n\nserver.listen(1337, '127.0.0.1');\n```\n\n执行`node example.js`启动服务, 然后TCP连接到 127.0.0.1:1337, 即可看到效果.\n\n# So Simple\nN的Hello World就是这么Simple. N能够实现的功能远远不止这些, 想要体会更多N的精彩之处, 赶快学习N的更多内容吧.\n\n\n","slug":"hello_world","published":1,"updated":"2015-10-12T04:33:25.000Z","_id":"cifmere190015vs1mawtp1ja6","comments":1,"layout":"post","photos":[],"link":""},{"title":"generator","date":"2014-01-02T08:00:10.000Z","_content":"\n## ES6\n[ES6(代号harmony)](http://wiki.ecmascript.org/doku.php)是下一代JavaScript语言规范, 目前还在制定当中. 在2014年底将会完成规范制定, 并有部分Engine实现. ES6包含众多新语言[特性](http://tc39wiki.calculist.org/es6/): Module, Class, Set, Map, iterator, generator, for-of...  \n\n众多的语法特性将为JS开发打开全新的天地. 这里主要介绍[generator](http://wiki.ecmascript.org/doku.php?id=harmony:generators)和[iterator](http://wiki.ecmascript.org/doku.php?id=harmony:iterators), 因为该特性能够以同步的代码实现异步的流程.\n\n<!-- more -->\n\n## generator & iterator\niterator和generator特性借鉴于Python, Ruby, smalltalk, 本来用于方便访问容器内各个元素. 该特性需要node v0.11.9并开启--harmony特性才能使用, 在chrome(29+)浏览器中需要在`chrome://flags/` 开启`Enable Experimental JavaScript`选项, 然后重启. 这里先介绍下相关的概念.\n\niterator(迭代器): 具有next方法的对象, 返回{done: true/false, value: returnValue}结构数据\n\niterable(可迭代变量): 具有内部方法`obj[@@iterator]()`的对象, 该方法会返回iterator.\n\ngenerator(生成器): 一种特殊的iterator, 其next()方法的返回结果由他的generator function定义. generator还包含一个throw方法, 他们next方法可以接受一个参数.\n\ngenerator function: 是generator的构造器方法, 在该方法内可以使用yield关键字. yield调用的地方可以传出value(通过next方法)或exception(通过throw方法). generator function的书写语法为 `function*`\n\ngenerator comprehension: 一种生成generator的简化表达式如: `(for (x of a) for (y of b) x * y)`\n\n\n在generator function内部可以使用 yield 语句：\n\n```\nfunction* genFunc () {\n    console.log('step 1')\n    yield 1\n    console.log('step 2')\n    yield 2\n    console.log('step 3')\n    return 3\n}\n```\n\n调用generator function的时候，你会获得一个generator对象\n\n```\nvar gen = genFunc()  // 可以传递参数\n```\n\n这个对象有一个方法叫做 next()。每当调用 next() 的时候，generator function内部就会执行直到遇到下一个 yield 语句，然后暂停在那里，并返回一个对象。这个对象含有被 yield 的值和generator函数的运行状态\n\n```\nvar ret = gen.next() // 输出: 'step 1'\nconsole.log(ret.value) // 1\nconsole.log(ret.done) // false\n```\n\n直到generator函数内部不再有 yield 语句存在了，这时你再调用 next()，获得的就会是该函数的常规返回值 (return 的值)：\n\n```\nret = gen.next() // 输出 'step 3'\nconsole.log(ret.value) // 3\nconsole.log(ret.done) // true\n```\n同时，iterator对象的 next() 方法是可以传递一个参数的。这个参数将会成为generator函数内对应 yield 语句的返回值：\n\n```\nfunction* genFunc () {\n    var result = yield 1\n    console.log(result)\n}\nvar gen = genFunc()\ngen.next() // 此时generator内部执行到 yield 1 并暂停，但还未对result赋值！\n// 即使异步也可以！\nsetTimeout(function () {\n    gen.next(123) // 给result赋值并继续执行，输出: 123\n}, 1000)\n```\n\nyield语句会暂停生成器方法中的代码执行, 但对外部代码没有影响, 外部代码可以继续执行下去. 这样generator function可以借助 yield 在需要的时候才继续执行剩余的语句，并且传递回一个值, 这其实是另外一种形式的回调, 而且这里可以使用同步的形式表达异步的流程, 没有函数嵌套. TJ大神的[co](https://github.com/visionmedia/co)流程控制库就是这个原理. [参考]()\n\n其他 generator function定义:\n\n```\nfunction* foo1() { };\nfunction *foo2() { };\nfunction * foo3() { };\n \nfoo1.toString(); // \"function* foo1() { }\"\nfoo2.toString(); // \"function* foo2() { }\"\nfoo3.toString(); // \"function* foo3() { }\"\nfoo1.constructor; // function GeneratorFunction() { [native code] }\n```\n\n\n几点需要注意的地方:\n\n* yield 只能在生成器构造方法中使用\n* yield 只会将它的第一个参数返回, 且至少有一个参数否则会报错\n* 生成器构造方法接受参数\n* next()方法接受一个参数, 该值会返回给yield的左值, next参数作为上一个yield的左值\n\n### for-of\nES6的`for of`表达式可在iterables上使用 `for (let x of iterable) { /* ... */ }`\n它会去调用`iterable.prototype[@@iterator]()`方法获取iterator对象. `Map.prototype`, \n`Set.prototype`以及所有包含`@@iterator`方法的都能使用`for of`表达式.\n\n`for in`表达式用法没有发生任何变化, 不能用于iterables上\n\n如果一个`iterator`拥有`@@iterator()`方法那他也是`iterable`的. ES6中大部分iterator都是iterable的, 内部方法会直接返回this(本身). 而且所有通过generator function和generator comprehension创建的generator都有iterable的.\n\n```\nconst lazySequence = (for (x of a) for (y of b) x * y);\nfor (let z of lazySequence) {\n  console.log(z);\n}\n```\n\n关于如何创建iterable对象和Generator Comprehension Desugaring可参看[这里](http://domenic.me/2013/09/06/es6-iterators-generators-and-iterables/)\n\n\n参考: \n\n* [es6-iterators-generators-and-iterables](http://domenic.me/2013/09/06/es6-iterators-generators-and-iterables/)\n* [segment问答](http://segmentfault.com/q/1010000000367154#a-1020000000373763)\n* [What are generators](http://tobyho.com/2013/06/16/what-are-generators/)\n* [es6中生成器函数介绍](https://www.imququ.com/post/generator-function-in-es6.html)\n* [迭代器和生成器](https://developer.mozilla.org/zh-CN/docs/JavaScript/Guide/Iterators_and_Generators)\n* [generators-in-v8](http://wingolog.org/archives/2013/05/08/generators-in-v8)\n* [on generators](http://wingolog.org/archives/2013/02/25/on-generators)\n* [Harmony Generator, yield, ES6, co框架学习](http://bg.biedalian.com/2013/12/21/harmony-generator.html)\n* [co中yield的n种重载](http://bg.biedalian.com/2014/01/08/what-can-i-yield.html)\n\n\n## 相关module: gnode, co, suspend, promise\ngenerator除了可以用于方便迭代之外, 在JS中(尤其是Node.js)估计最有用的地方应该是流程控制了. 利用yield的特性可以使用同步的代码开发异步的流程, 避免逻辑混乱和函数嵌套. 目前TJ大神已经开发除了新的流程控制模块[co](https://github.com/visionmedia/co), ([这里对generator和co进行了详细介绍](http://www.html-js.com/article/1687)) 并在此基础之上开发了全新的web 框架koa. 等0.12版发布之后, koa可以很方便应用, 届时又将是一个很火的框架. 另外[suspend](https://github.com/jmar777/suspend)也是使用generator特性实现的全新流程控制解决方案. \n\n虽然现在ES6还没有被实现, 但是[gnode](https://github.com/TooTallNate/gnode)可以让现在的JS引擎支持generator特性, 有兴趣的同学可以尝试下. Node相交于浏览器没有多浏览器兼容问题, 一旦v8完全支持即可迅速采用, 另外0.12版本的node马上就会到来.\n\n使用co可以使用同步的代码实现异步的流程, 下例中三个读取文件的操作顺序执行, 但没有嵌套代码\n\n```\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n并行执行的异步代码\n\n```\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n这只是简单的展示, co支持参数支持, 异常处理, 只有300行代码, 支持promise, thunk, array, object, generator, generator function. 关于co的详细使用可参看co[github](https://github.com/visionmedia/co), 有兴趣的同学可以尝试下[koa](https://github.com/koajs/koa)框架 \n\n## 参考资料\n\n* [ES6 proposals official wiki](http://wiki.ecmascript.org/doku.php?id=harmony:proposals)\n* [ES6 proposals](http://espadrine.github.io/New-In-A-Spec/es6/)\n* [MDN iterator and generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n* [ES6资源](http://addyosmani.com/blog/ecmascript-6-resources-for-the-curious-javascripter/)\n* [Using es6 today](http://globaldev.co.uk/2013/09/es6-part-1/)\n* [ES6 Feature proposals](http://tc39wiki.calculist.org/es6/)\n* [Harmony process](http://tc39wiki.calculist.org/about/harmony/)\n* [ES6规范制作流程](http://www.cnblogs.com/ziyunfei/archive/2012/12/05/2802382.html)\n* [ES6相关文章(中文)](http://www.tuicool.com/topics/11060047?st=0&lang=0&pn=3)\n* [ES6各浏览器实现情况](http://kangax.github.io/es5-compat-table/es6/)\n* [ECMAScript 6，一定要了解的10个特性](http://www.xdf.me/?p=754)\n* [eight cool features coming in es6](http://net.tutsplus.com/tutorials/javascript-ajax/eight-cool-features-coming-in-es6/)\n* [what's the big deal with generator](http://devsmash.com/blog/whats-the-big-deal-with-generators)\n* [New in javascript 1.7](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.7?redirectlocale=en-US&redirectslug=JavaScript%2FNew_in_JavaScript%2F1.7)\n* [javascript-yield](http://jlongster.com/2012/10/05/javascript-yield.html)\n* [promise](http://wiki.commonjs.org/wiki/Promises)\n* [when.js](https://github.com/cujojs/when)\n* [Q](https://github.com/kriskowal/q)\n\n","source":"_posts/generator.md","raw":"title: generator\ndate: 2014-01-02 16:00:10\ntags: ES6 异步流程\n---\n\n## ES6\n[ES6(代号harmony)](http://wiki.ecmascript.org/doku.php)是下一代JavaScript语言规范, 目前还在制定当中. 在2014年底将会完成规范制定, 并有部分Engine实现. ES6包含众多新语言[特性](http://tc39wiki.calculist.org/es6/): Module, Class, Set, Map, iterator, generator, for-of...  \n\n众多的语法特性将为JS开发打开全新的天地. 这里主要介绍[generator](http://wiki.ecmascript.org/doku.php?id=harmony:generators)和[iterator](http://wiki.ecmascript.org/doku.php?id=harmony:iterators), 因为该特性能够以同步的代码实现异步的流程.\n\n<!-- more -->\n\n## generator & iterator\niterator和generator特性借鉴于Python, Ruby, smalltalk, 本来用于方便访问容器内各个元素. 该特性需要node v0.11.9并开启--harmony特性才能使用, 在chrome(29+)浏览器中需要在`chrome://flags/` 开启`Enable Experimental JavaScript`选项, 然后重启. 这里先介绍下相关的概念.\n\niterator(迭代器): 具有next方法的对象, 返回{done: true/false, value: returnValue}结构数据\n\niterable(可迭代变量): 具有内部方法`obj[@@iterator]()`的对象, 该方法会返回iterator.\n\ngenerator(生成器): 一种特殊的iterator, 其next()方法的返回结果由他的generator function定义. generator还包含一个throw方法, 他们next方法可以接受一个参数.\n\ngenerator function: 是generator的构造器方法, 在该方法内可以使用yield关键字. yield调用的地方可以传出value(通过next方法)或exception(通过throw方法). generator function的书写语法为 `function*`\n\ngenerator comprehension: 一种生成generator的简化表达式如: `(for (x of a) for (y of b) x * y)`\n\n\n在generator function内部可以使用 yield 语句：\n\n```\nfunction* genFunc () {\n    console.log('step 1')\n    yield 1\n    console.log('step 2')\n    yield 2\n    console.log('step 3')\n    return 3\n}\n```\n\n调用generator function的时候，你会获得一个generator对象\n\n```\nvar gen = genFunc()  // 可以传递参数\n```\n\n这个对象有一个方法叫做 next()。每当调用 next() 的时候，generator function内部就会执行直到遇到下一个 yield 语句，然后暂停在那里，并返回一个对象。这个对象含有被 yield 的值和generator函数的运行状态\n\n```\nvar ret = gen.next() // 输出: 'step 1'\nconsole.log(ret.value) // 1\nconsole.log(ret.done) // false\n```\n\n直到generator函数内部不再有 yield 语句存在了，这时你再调用 next()，获得的就会是该函数的常规返回值 (return 的值)：\n\n```\nret = gen.next() // 输出 'step 3'\nconsole.log(ret.value) // 3\nconsole.log(ret.done) // true\n```\n同时，iterator对象的 next() 方法是可以传递一个参数的。这个参数将会成为generator函数内对应 yield 语句的返回值：\n\n```\nfunction* genFunc () {\n    var result = yield 1\n    console.log(result)\n}\nvar gen = genFunc()\ngen.next() // 此时generator内部执行到 yield 1 并暂停，但还未对result赋值！\n// 即使异步也可以！\nsetTimeout(function () {\n    gen.next(123) // 给result赋值并继续执行，输出: 123\n}, 1000)\n```\n\nyield语句会暂停生成器方法中的代码执行, 但对外部代码没有影响, 外部代码可以继续执行下去. 这样generator function可以借助 yield 在需要的时候才继续执行剩余的语句，并且传递回一个值, 这其实是另外一种形式的回调, 而且这里可以使用同步的形式表达异步的流程, 没有函数嵌套. TJ大神的[co](https://github.com/visionmedia/co)流程控制库就是这个原理. [参考]()\n\n其他 generator function定义:\n\n```\nfunction* foo1() { };\nfunction *foo2() { };\nfunction * foo3() { };\n \nfoo1.toString(); // \"function* foo1() { }\"\nfoo2.toString(); // \"function* foo2() { }\"\nfoo3.toString(); // \"function* foo3() { }\"\nfoo1.constructor; // function GeneratorFunction() { [native code] }\n```\n\n\n几点需要注意的地方:\n\n* yield 只能在生成器构造方法中使用\n* yield 只会将它的第一个参数返回, 且至少有一个参数否则会报错\n* 生成器构造方法接受参数\n* next()方法接受一个参数, 该值会返回给yield的左值, next参数作为上一个yield的左值\n\n### for-of\nES6的`for of`表达式可在iterables上使用 `for (let x of iterable) { /* ... */ }`\n它会去调用`iterable.prototype[@@iterator]()`方法获取iterator对象. `Map.prototype`, \n`Set.prototype`以及所有包含`@@iterator`方法的都能使用`for of`表达式.\n\n`for in`表达式用法没有发生任何变化, 不能用于iterables上\n\n如果一个`iterator`拥有`@@iterator()`方法那他也是`iterable`的. ES6中大部分iterator都是iterable的, 内部方法会直接返回this(本身). 而且所有通过generator function和generator comprehension创建的generator都有iterable的.\n\n```\nconst lazySequence = (for (x of a) for (y of b) x * y);\nfor (let z of lazySequence) {\n  console.log(z);\n}\n```\n\n关于如何创建iterable对象和Generator Comprehension Desugaring可参看[这里](http://domenic.me/2013/09/06/es6-iterators-generators-and-iterables/)\n\n\n参考: \n\n* [es6-iterators-generators-and-iterables](http://domenic.me/2013/09/06/es6-iterators-generators-and-iterables/)\n* [segment问答](http://segmentfault.com/q/1010000000367154#a-1020000000373763)\n* [What are generators](http://tobyho.com/2013/06/16/what-are-generators/)\n* [es6中生成器函数介绍](https://www.imququ.com/post/generator-function-in-es6.html)\n* [迭代器和生成器](https://developer.mozilla.org/zh-CN/docs/JavaScript/Guide/Iterators_and_Generators)\n* [generators-in-v8](http://wingolog.org/archives/2013/05/08/generators-in-v8)\n* [on generators](http://wingolog.org/archives/2013/02/25/on-generators)\n* [Harmony Generator, yield, ES6, co框架学习](http://bg.biedalian.com/2013/12/21/harmony-generator.html)\n* [co中yield的n种重载](http://bg.biedalian.com/2014/01/08/what-can-i-yield.html)\n\n\n## 相关module: gnode, co, suspend, promise\ngenerator除了可以用于方便迭代之外, 在JS中(尤其是Node.js)估计最有用的地方应该是流程控制了. 利用yield的特性可以使用同步的代码开发异步的流程, 避免逻辑混乱和函数嵌套. 目前TJ大神已经开发除了新的流程控制模块[co](https://github.com/visionmedia/co), ([这里对generator和co进行了详细介绍](http://www.html-js.com/article/1687)) 并在此基础之上开发了全新的web 框架koa. 等0.12版发布之后, koa可以很方便应用, 届时又将是一个很火的框架. 另外[suspend](https://github.com/jmar777/suspend)也是使用generator特性实现的全新流程控制解决方案. \n\n虽然现在ES6还没有被实现, 但是[gnode](https://github.com/TooTallNate/gnode)可以让现在的JS引擎支持generator特性, 有兴趣的同学可以尝试下. Node相交于浏览器没有多浏览器兼容问题, 一旦v8完全支持即可迅速采用, 另外0.12版本的node马上就会到来.\n\n使用co可以使用同步的代码实现异步的流程, 下例中三个读取文件的操作顺序执行, 但没有嵌套代码\n\n```\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n并行执行的异步代码\n\n```\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n这只是简单的展示, co支持参数支持, 异常处理, 只有300行代码, 支持promise, thunk, array, object, generator, generator function. 关于co的详细使用可参看co[github](https://github.com/visionmedia/co), 有兴趣的同学可以尝试下[koa](https://github.com/koajs/koa)框架 \n\n## 参考资料\n\n* [ES6 proposals official wiki](http://wiki.ecmascript.org/doku.php?id=harmony:proposals)\n* [ES6 proposals](http://espadrine.github.io/New-In-A-Spec/es6/)\n* [MDN iterator and generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n* [ES6资源](http://addyosmani.com/blog/ecmascript-6-resources-for-the-curious-javascripter/)\n* [Using es6 today](http://globaldev.co.uk/2013/09/es6-part-1/)\n* [ES6 Feature proposals](http://tc39wiki.calculist.org/es6/)\n* [Harmony process](http://tc39wiki.calculist.org/about/harmony/)\n* [ES6规范制作流程](http://www.cnblogs.com/ziyunfei/archive/2012/12/05/2802382.html)\n* [ES6相关文章(中文)](http://www.tuicool.com/topics/11060047?st=0&lang=0&pn=3)\n* [ES6各浏览器实现情况](http://kangax.github.io/es5-compat-table/es6/)\n* [ECMAScript 6，一定要了解的10个特性](http://www.xdf.me/?p=754)\n* [eight cool features coming in es6](http://net.tutsplus.com/tutorials/javascript-ajax/eight-cool-features-coming-in-es6/)\n* [what's the big deal with generator](http://devsmash.com/blog/whats-the-big-deal-with-generators)\n* [New in javascript 1.7](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.7?redirectlocale=en-US&redirectslug=JavaScript%2FNew_in_JavaScript%2F1.7)\n* [javascript-yield](http://jlongster.com/2012/10/05/javascript-yield.html)\n* [promise](http://wiki.commonjs.org/wiki/Promises)\n* [when.js](https://github.com/cujojs/when)\n* [Q](https://github.com/kriskowal/q)\n\n","slug":"generator","published":1,"updated":"2015-10-12T04:33:52.000Z","_id":"cifmere1g0019vs1mfh2kvfxh","comments":1,"layout":"post","photos":[],"link":""},{"title":"Express 升级","date":"2014-02-25T06:51:56.000Z","_content":"Express 是 Node.js 平台使用最多, 最知名的 web 框架, 目前正式版本为 3.5\nNode 0.12 即将发布, Connect 3.0 和 Express 4.0 也都在紧锣密鼓的开发当中\n3.3 号, Express 4 发布了 RC 版. 这里介绍下Express 4 的最新特点\n\n<!-- more -->\n\n### Express 4\nExpress 4 将生成项目架构命令行工具移到了单独的项目 [express-generator](https://github.com/expressjs/generator),\n并且移除了对 Connect 的依赖. 具体特点为:\n\n* 健壮的路由系统\n* 包含 HTTP helpers (跳转, 缓存等)\n* 试图系统支持超过 14 中模板引擎\n* Content negotiation\n* 专注高性能\n* 基于 environment 的配置\n* 项目框架生成命令行工具\n* 测试全面\n\nExpress 两大主要变化: 去掉了对 connect 中间件的捆绑, 如果需要可以添加到项目 package.json 使用, 这样使得中间件可以更加灵活的更新和 fix bug\n而不会影响到 Express; 增强的路由系统 具体信息参看[New features in 4.x](https://github.com/visionmedia/express/wiki/New-features-in-4.x)\n\n关于 Express 3.0 到 4.0 迁移可参看这里[Migrating from 3.x to 4.x](https://github.com/visionmedia/express/wiki/Migrating-from-3.x-to-4.x)\n\nExpress 的设计哲学为: 提供 精简, 健壮的 HTTP server 开发工具. 为 单页应用, 网站, 混合类应用, 公共 HTTP API\n提供完美解决方案.\n\nExpress 不强制用户使用指定的 ORM 或 模板引擎, 用户可以自由选择. \n\n关于 Express 4 完整的 API, 可[参看](http://expressjs.com/4x/api.html)\n\n\n参考:\n\n* [Express API](http://expressjs.org)\n* [Express github](https://github.com/visionmedia/express)\n* [new features in 4.x](https://github.com/visionmedia/express/wiki/New-features-in-4.x)\n* [express migrate from 3.x to 4.x](https://github.com/visionmedia/express/wiki/Migrating-from-3.x-to-4.x)\n* [ExpressJS 4.0: New Features and Upgrading from 3.0](http://scotch.io/bar-talk/expressjs-4-0-new-features-and-upgrading-from-3-0)\n* [Express roadmap](https://github.com/visionmedia/express/wiki/4.x-roadmap)\n\n\n\n### Connect 3.0\n\n[Connect](https://github.com/senchalabs/connect) 是一个 Node.js 的中间件层, \n可扩展的 HTTP server 框架. Express 3.0 即是建立在 connect 之上. 跟随 Node 0.12\n的步伐, Connect 3.0 也在开发当中, 主要的调整为:\n\n* 中间件会被迁移到 [expressjs](http://github.com/expressjs) 组织的独立项目中\n* 所有的中间件不止能适用于 Connect, 还可以适用于相似的框架如 [restify](https://github.com/mcavage/node-restify), 因此所有的 Node patched 会被移除.\n* 停止对 Node 0.8 的支持.\n* 网站文档将会被移除, 可以查看项目的 README 文档作为替代.\n\n注: 部分中间件将会被停止支持: cookieParser, limit, multipart, staticCache, query. \n可以使用其他插件替代, 具体参看 [connect middleware](https://github.com/senchalabs/connect#middleware).\n这部分插件会对部分 Express 3 造成影响, 在项目启动时候会看到升级提示警告: `connect.bodyParser()` 将不再支持.\n可以使用\n```\napp.use(connect.urlencoded())\napp.use(connect.json())\n```\n替代, 具体的信息, 参看[升级提示](https://github.com/senchalabs/connect/wiki/Connect-3.0)\n\n关于 Connect 的最新进展, 相关中间件, 详细文档, 可以参看其 [Github](https://github.com/senchalabs/connect) 项目,\n如果有兴趣维护这些中间件可以联系 [expressjs 的成员](https://github.com/orgs/expressjs/members).\n\n参考:\n\n* [Connect doc](http://www.senchalabs.org/connect/)\n* [Connect 3.0 migration guide](https://github.com/senchalabs/connect/wiki/Connect-3.0)\n* [Connect github](https://github.com/senchalabs/connect)\n","source":"_posts/express-upgrade.md","raw":"title: Express 升级\ndate: 2014-02-25 14:51:56\ntags: Express upgrade\n---\nExpress 是 Node.js 平台使用最多, 最知名的 web 框架, 目前正式版本为 3.5\nNode 0.12 即将发布, Connect 3.0 和 Express 4.0 也都在紧锣密鼓的开发当中\n3.3 号, Express 4 发布了 RC 版. 这里介绍下Express 4 的最新特点\n\n<!-- more -->\n\n### Express 4\nExpress 4 将生成项目架构命令行工具移到了单独的项目 [express-generator](https://github.com/expressjs/generator),\n并且移除了对 Connect 的依赖. 具体特点为:\n\n* 健壮的路由系统\n* 包含 HTTP helpers (跳转, 缓存等)\n* 试图系统支持超过 14 中模板引擎\n* Content negotiation\n* 专注高性能\n* 基于 environment 的配置\n* 项目框架生成命令行工具\n* 测试全面\n\nExpress 两大主要变化: 去掉了对 connect 中间件的捆绑, 如果需要可以添加到项目 package.json 使用, 这样使得中间件可以更加灵活的更新和 fix bug\n而不会影响到 Express; 增强的路由系统 具体信息参看[New features in 4.x](https://github.com/visionmedia/express/wiki/New-features-in-4.x)\n\n关于 Express 3.0 到 4.0 迁移可参看这里[Migrating from 3.x to 4.x](https://github.com/visionmedia/express/wiki/Migrating-from-3.x-to-4.x)\n\nExpress 的设计哲学为: 提供 精简, 健壮的 HTTP server 开发工具. 为 单页应用, 网站, 混合类应用, 公共 HTTP API\n提供完美解决方案.\n\nExpress 不强制用户使用指定的 ORM 或 模板引擎, 用户可以自由选择. \n\n关于 Express 4 完整的 API, 可[参看](http://expressjs.com/4x/api.html)\n\n\n参考:\n\n* [Express API](http://expressjs.org)\n* [Express github](https://github.com/visionmedia/express)\n* [new features in 4.x](https://github.com/visionmedia/express/wiki/New-features-in-4.x)\n* [express migrate from 3.x to 4.x](https://github.com/visionmedia/express/wiki/Migrating-from-3.x-to-4.x)\n* [ExpressJS 4.0: New Features and Upgrading from 3.0](http://scotch.io/bar-talk/expressjs-4-0-new-features-and-upgrading-from-3-0)\n* [Express roadmap](https://github.com/visionmedia/express/wiki/4.x-roadmap)\n\n\n\n### Connect 3.0\n\n[Connect](https://github.com/senchalabs/connect) 是一个 Node.js 的中间件层, \n可扩展的 HTTP server 框架. Express 3.0 即是建立在 connect 之上. 跟随 Node 0.12\n的步伐, Connect 3.0 也在开发当中, 主要的调整为:\n\n* 中间件会被迁移到 [expressjs](http://github.com/expressjs) 组织的独立项目中\n* 所有的中间件不止能适用于 Connect, 还可以适用于相似的框架如 [restify](https://github.com/mcavage/node-restify), 因此所有的 Node patched 会被移除.\n* 停止对 Node 0.8 的支持.\n* 网站文档将会被移除, 可以查看项目的 README 文档作为替代.\n\n注: 部分中间件将会被停止支持: cookieParser, limit, multipart, staticCache, query. \n可以使用其他插件替代, 具体参看 [connect middleware](https://github.com/senchalabs/connect#middleware).\n这部分插件会对部分 Express 3 造成影响, 在项目启动时候会看到升级提示警告: `connect.bodyParser()` 将不再支持.\n可以使用\n```\napp.use(connect.urlencoded())\napp.use(connect.json())\n```\n替代, 具体的信息, 参看[升级提示](https://github.com/senchalabs/connect/wiki/Connect-3.0)\n\n关于 Connect 的最新进展, 相关中间件, 详细文档, 可以参看其 [Github](https://github.com/senchalabs/connect) 项目,\n如果有兴趣维护这些中间件可以联系 [expressjs 的成员](https://github.com/orgs/expressjs/members).\n\n参考:\n\n* [Connect doc](http://www.senchalabs.org/connect/)\n* [Connect 3.0 migration guide](https://github.com/senchalabs/connect/wiki/Connect-3.0)\n* [Connect github](https://github.com/senchalabs/connect)\n","slug":"express-upgrade","published":1,"updated":"2015-10-12T04:33:56.000Z","_id":"cifmere1j001cvs1my4u1ljpz","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js事件机制","date":"2013-11-08T06:50:41.000Z","_content":"Node.js在Github代码仓库上的描述为Evented I/O for V8 JavaScript. 这句话清晰表达了Node.js最大特点Evented. Node.js通过事件异步机制成功突破单线程编程模型的性能机制, 并有前后端编程模型统一, 性能更高等优点, 从而迅速被大家所接受.本文介绍Node.js的事件机制.\n\n<!-- more -->\n\n## Event 模块\nevent模块是Node.js的核心原生模块, 该模块包含EventEmitter类, 提供事件绑定, 触发等相关方法. Node.js的大部分模块都继承自Event模块. 与前端DOM树事件不同之处在于不存在冒泡, 捕获等行为, 亦没有preventDefault(), stopPropagation(), stopImmediatePropagation(). 具体参看官方[API](http://nodejs.org/api/events.html)\n\nclass: events.EventEmitter\n\n* addListner(event, listener)\n* on(event, listner)\n* once(event, listner)\n* removeListener(event, listner)\n* removeAllListener([event])\n* setMaxListeners(n)\n* listeners(event)\n* emit(event, [arg1], [arg2], [...])\n* Class Method: EventEmitter.listenerCount(emitter, event)\n* Event: 'newListener'\n* Event: 'removeListener'\n\n关于事件的几点说明:\n\n* 事件机制本身是hook的一种实现, 可用于导出内部数据或状态\n* 事件命名通常遵循camel-cased字符串规则, 但是没有强制限制\n* 绑定到对象上得方法通常叫做监听器, 在监听器内部this指向EventEmitter对象\n* 如果事件对象遇到error, node会触发一个`'error'`事件, 如果事件没有绑定listener, node会打印stack trace, 然后退出程序\n* 一个对象的某个事件绑定listener超过默认10之后, node会打印警告, 该行为对查找memory leak非常有用.可以使用setMaxListners(n)修改这个默认行为, 设为0为不限制\n\n## 继承Event\n可使用原生`util`模块提供的`inherits`方法继承EventEmitter对象\n\n```\nvar util = require(\"util\");\nvar events = require(\"events\");\n\nfunction MyStream() {\n    events.EventEmitter.call(this);\n}\n\nutil.inherits(MyStream, events.EventEmitter);\n\nMyStream.prototype.write = function(data) {\n    this.emit(\"data\", data);\n}\n\nvar stream = new MyStream();\n\nconsole.log(stream instanceof events.EventEmitter); // true\nconsole.log(MyStream.super_ === events.EventEmitter); // true\n\nstream.on(\"data\", function(data) {\n    console.log('Received data: \"' + data + '\"');\n})\nstream.write(\"It works!\"); // Received data: \"It works!\"\n```\n\n## 其他\nNode中回调函数通常作为方法的最后参数传递.\n\n\n### 参考\n\n* [深入浅出Node.js事件机制](http://www.infoq.com/cn/articles/tyq-nodejs-event)\n* [官方API](http://nodejs.org/api/events.html)\n\n\n","source":"_posts/events.md","raw":"title: Node.js事件机制\ndate: 2013-11-08 14:50:41\ntags: Module\n---\nNode.js在Github代码仓库上的描述为Evented I/O for V8 JavaScript. 这句话清晰表达了Node.js最大特点Evented. Node.js通过事件异步机制成功突破单线程编程模型的性能机制, 并有前后端编程模型统一, 性能更高等优点, 从而迅速被大家所接受.本文介绍Node.js的事件机制.\n\n<!-- more -->\n\n## Event 模块\nevent模块是Node.js的核心原生模块, 该模块包含EventEmitter类, 提供事件绑定, 触发等相关方法. Node.js的大部分模块都继承自Event模块. 与前端DOM树事件不同之处在于不存在冒泡, 捕获等行为, 亦没有preventDefault(), stopPropagation(), stopImmediatePropagation(). 具体参看官方[API](http://nodejs.org/api/events.html)\n\nclass: events.EventEmitter\n\n* addListner(event, listener)\n* on(event, listner)\n* once(event, listner)\n* removeListener(event, listner)\n* removeAllListener([event])\n* setMaxListeners(n)\n* listeners(event)\n* emit(event, [arg1], [arg2], [...])\n* Class Method: EventEmitter.listenerCount(emitter, event)\n* Event: 'newListener'\n* Event: 'removeListener'\n\n关于事件的几点说明:\n\n* 事件机制本身是hook的一种实现, 可用于导出内部数据或状态\n* 事件命名通常遵循camel-cased字符串规则, 但是没有强制限制\n* 绑定到对象上得方法通常叫做监听器, 在监听器内部this指向EventEmitter对象\n* 如果事件对象遇到error, node会触发一个`'error'`事件, 如果事件没有绑定listener, node会打印stack trace, 然后退出程序\n* 一个对象的某个事件绑定listener超过默认10之后, node会打印警告, 该行为对查找memory leak非常有用.可以使用setMaxListners(n)修改这个默认行为, 设为0为不限制\n\n## 继承Event\n可使用原生`util`模块提供的`inherits`方法继承EventEmitter对象\n\n```\nvar util = require(\"util\");\nvar events = require(\"events\");\n\nfunction MyStream() {\n    events.EventEmitter.call(this);\n}\n\nutil.inherits(MyStream, events.EventEmitter);\n\nMyStream.prototype.write = function(data) {\n    this.emit(\"data\", data);\n}\n\nvar stream = new MyStream();\n\nconsole.log(stream instanceof events.EventEmitter); // true\nconsole.log(MyStream.super_ === events.EventEmitter); // true\n\nstream.on(\"data\", function(data) {\n    console.log('Received data: \"' + data + '\"');\n})\nstream.write(\"It works!\"); // Received data: \"It works!\"\n```\n\n## 其他\nNode中回调函数通常作为方法的最后参数传递.\n\n\n### 参考\n\n* [深入浅出Node.js事件机制](http://www.infoq.com/cn/articles/tyq-nodejs-event)\n* [官方API](http://nodejs.org/api/events.html)\n\n\n","slug":"events","published":1,"updated":"2015-10-12T04:33:59.000Z","_id":"cifmere1l001fvs1mng4umc9i","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js企业开发 六总结","date":"2014-01-28T08:28:14.000Z","_content":"Node.js 企业开发系列博客大致将企业开发涉及到的方面进行了概括和总结, 大部分内容并没有做详细研究和解释, 有兴趣的同学需要自己去深挖. 有的方面没有涵盖到例如:\n\n* 与其他平台协作\n* 内存泄露, 进程假死\n* 项目工程化\n* 代码注释, 文档\n* 私有 NPM 架设\n\nNode 是一个年轻的平台, 企业化之路才刚刚开始, 我们不仅可以参考其他语言平台, 在企业环境中使用Node.js大公司的经验和解决方案. 还可以参看Node社区众多开发者遇到的问题和解决方法. 2014年 NPM 会越来越好(npm, Inc. nodejitsu两家公司投入维护), 0.12很快会发布, 1.0也可能会到来, 相信这一年将会是 Node 企业化应用的起步之年. Node 小伙们都硬起来吧.\n\n\n\n\n","source":"_posts/enterprise_conclusion.md","raw":"title: Node.js企业开发 六总结\ndate: 2014-01-28 16:28:14\ntags:\n---\nNode.js 企业开发系列博客大致将企业开发涉及到的方面进行了概括和总结, 大部分内容并没有做详细研究和解释, 有兴趣的同学需要自己去深挖. 有的方面没有涵盖到例如:\n\n* 与其他平台协作\n* 内存泄露, 进程假死\n* 项目工程化\n* 代码注释, 文档\n* 私有 NPM 架设\n\nNode 是一个年轻的平台, 企业化之路才刚刚开始, 我们不仅可以参考其他语言平台, 在企业环境中使用Node.js大公司的经验和解决方案. 还可以参看Node社区众多开发者遇到的问题和解决方法. 2014年 NPM 会越来越好(npm, Inc. nodejitsu两家公司投入维护), 0.12很快会发布, 1.0也可能会到来, 相信这一年将会是 Node 企业化应用的起步之年. Node 小伙们都硬起来吧.\n\n\n\n\n","slug":"enterprise_conclusion","published":1,"updated":"2015-10-10T10:21:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifmere1n001hvs1mta5odjca"},{"title":"Dev Tools","date":"2013-10-18T06:55:34.000Z","_content":"工具存在的价值为帮助人们提高工作的效率甚至完成以前没法完成的工作. N开发同样有许多优秀的工具帮助提升效率. 目前比较流行好用的N开发工具有: [Sublime Text](http://www.sublimetext.com/), [WebStorm](http://www.jetbrains.com/webstorm/), [Cloud9](https://c9.io/), [NodeEclipse](http://www.nodeclipse.org/).\n\n<!-- more -->\n\n# [Sublime Text](http://www.sublimetext.com/)\nSublime是一个跨平台的编辑器, 界面简单清爽, 功能强大, 有许多插件和主题,\n快速的代码文件切换功能. 适合前端, Ruby, Python, Node.js. 目前许多国外的大公司开发者都在使用并推荐该开发工具. \n\n* 跨平台\n* 文件, 项目, 方法快速到达\n* 支持多选\n* 支持自定义: 主题,插件,字体,快捷键…\n* 支持免费\n\n个人也强烈推荐Sublime Text, 目前正式版本为2.0, 3.0的beta版以发布, 主要提升了性能, 大家可以尝试.\n\n\n# WebStorm\nWebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaSscript IDE”等。与IntelliJ IDEA同源[1]，继承了IntelliJ IDEA强大的JS部分的功能。\n\nWebStorm从级别来上来说算是IDE, 不是简单的编辑器. WebStorm支持语法提示功能, 功能强大, 但是不是免费的, 不过网上有破解版的\n\n* 智能编辑器\n* 代码质量分析,检查\n* 版本控制工具集成\n* 支持最新前端技术: Node.js TypeScript CoffeeScript Dart EJS Handlebars, Mustache …\n* 跨平台\n\n# [Node.js tools for Visual Studio](https://nodejstools.codeplex.com/)\n随着Node.js快速发展成为后端服务开发的一个平台, 微软也越来越重视Node.js. 并且发布了Visual Studio的Node.js开发工具, 该工具不仅具有最基础的开发, 调试功能, 而且大大简化部署到Windows Azure和远端调试的功能. 该工具能让开发者享受到Visual Studio的众多优秀功能, 比如代码提示等.\n\n\n\n\n\n# NodeEclipse\nNodeEclipse本质上是Eclipse的一个插件或扩展, 在Eclipse的基础只上添加了对Node.js的支持. 目标是实现一站式Node.js开发工具.\n具体内容参看[官网](http://www.nodeclipse.org/)\n\n# Cloud9\nCloud9是一个云端开发工具, 能够实现 code anywhere anytime. 方便程序员之间的协作开发, 目前添加了对Node.js的完全集成.\n\n# 其他\n\n\nN的开发语言是JavaScript, 所以任何能开发JS的工具都能用来开发N:\n\n* [Nide](http://coreh.github.io/nide/)\n* Vim\n* Editplus\n* Visual Studio & Webmatrix\n* Textmate\n* UltraEdit\n\n开发工具众多, 每个程序员都有自己的喜好和偏爱, 没有最好的编辑器, 只有最适合自己的编辑器, 具体哪个适合你, 还需要自己来体验比较选择. \n\n\n\n\n\n","source":"_posts/dev-tools.md","raw":"title: Dev Tools\ndate: 2013-10-18 14:55:34\ntags: 工具\n---\n工具存在的价值为帮助人们提高工作的效率甚至完成以前没法完成的工作. N开发同样有许多优秀的工具帮助提升效率. 目前比较流行好用的N开发工具有: [Sublime Text](http://www.sublimetext.com/), [WebStorm](http://www.jetbrains.com/webstorm/), [Cloud9](https://c9.io/), [NodeEclipse](http://www.nodeclipse.org/).\n\n<!-- more -->\n\n# [Sublime Text](http://www.sublimetext.com/)\nSublime是一个跨平台的编辑器, 界面简单清爽, 功能强大, 有许多插件和主题,\n快速的代码文件切换功能. 适合前端, Ruby, Python, Node.js. 目前许多国外的大公司开发者都在使用并推荐该开发工具. \n\n* 跨平台\n* 文件, 项目, 方法快速到达\n* 支持多选\n* 支持自定义: 主题,插件,字体,快捷键…\n* 支持免费\n\n个人也强烈推荐Sublime Text, 目前正式版本为2.0, 3.0的beta版以发布, 主要提升了性能, 大家可以尝试.\n\n\n# WebStorm\nWebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaSscript IDE”等。与IntelliJ IDEA同源[1]，继承了IntelliJ IDEA强大的JS部分的功能。\n\nWebStorm从级别来上来说算是IDE, 不是简单的编辑器. WebStorm支持语法提示功能, 功能强大, 但是不是免费的, 不过网上有破解版的\n\n* 智能编辑器\n* 代码质量分析,检查\n* 版本控制工具集成\n* 支持最新前端技术: Node.js TypeScript CoffeeScript Dart EJS Handlebars, Mustache …\n* 跨平台\n\n# [Node.js tools for Visual Studio](https://nodejstools.codeplex.com/)\n随着Node.js快速发展成为后端服务开发的一个平台, 微软也越来越重视Node.js. 并且发布了Visual Studio的Node.js开发工具, 该工具不仅具有最基础的开发, 调试功能, 而且大大简化部署到Windows Azure和远端调试的功能. 该工具能让开发者享受到Visual Studio的众多优秀功能, 比如代码提示等.\n\n\n\n\n\n# NodeEclipse\nNodeEclipse本质上是Eclipse的一个插件或扩展, 在Eclipse的基础只上添加了对Node.js的支持. 目标是实现一站式Node.js开发工具.\n具体内容参看[官网](http://www.nodeclipse.org/)\n\n# Cloud9\nCloud9是一个云端开发工具, 能够实现 code anywhere anytime. 方便程序员之间的协作开发, 目前添加了对Node.js的完全集成.\n\n# 其他\n\n\nN的开发语言是JavaScript, 所以任何能开发JS的工具都能用来开发N:\n\n* [Nide](http://coreh.github.io/nide/)\n* Vim\n* Editplus\n* Visual Studio & Webmatrix\n* Textmate\n* UltraEdit\n\n开发工具众多, 每个程序员都有自己的喜好和偏爱, 没有最好的编辑器, 只有最适合自己的编辑器, 具体哪个适合你, 还需要自己来体验比较选择. \n\n\n\n\n\n","slug":"dev-tools","published":1,"updated":"2015-10-12T04:34:10.000Z","_id":"cifmere1p001ivs1mwmw00nj2","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js企业开发 三调试&测试","date":"2014-01-15T14:55:36.000Z","_content":"程序开发调试和测试是两个非常重要的环节, 在企业级应用开发中尤为重要.\n\n## 调试\n\n### console\n[console](http://nodejs.org/api/console.html) 想必是大家最熟悉, 使用最多的调试方法了, Node 的 console 模块为内置原生模块, 包含了一些基本方法(log, error, info, warn, dir, time, trace, assert)将变量输出到 std 流中. 可以实现最基本的调试功能.\n\n<!-- more -->\n\n### debugger\n[debugger](http://nodejs.org/api/debugger.html) 模块: V8 包含一个扩展调试器, 可以通过 TCP 协议在进程外访问, Node 包含一个内置的 debugger 客户端. 启动程序时添加 `debug` 参数可以启动.\n\n```% node debug myscript.js```\n\n该客户端没有实现所有功能, 但可以实现分步调试. 在代码中添加 `debugger;` 语句可以实现断点功能. \n还可以实现 watcher 功能, 具体使用方法可参看官方 API.\n\n### node-inspector\n\n[node-inspector](https://github.com/node-inspector/node-inspector) 是一个第三方模块, 是一个基于 Blink 开发工具的 Node.js 调试器. 通过 TCP 连接和 Node 程序通信, 实现调试功能. 跟浏览器中的 JS 调试工具有相同的功能, 通过该模块就能获的跟浏览器中相同的 JS 调试体验. 具体使用方法和步骤可以参看 [howtonode--Debugging with node-inspector](http://howtonode.org/debugging-with-node-inspector), [Taking Baby Steps with Node.js – Debugging with node-inspector](http://elegantcode.com/2011/01/14/taking-baby-steps-with-node-js-debugging-with-node-inspector/) 及 [node-inspector 百度经验](http://jingyan.baidu.com/article/dca1fa6fbd580ff1a44052de.html)\n\n另外 [debug](https://github.com/visionmedia/debug) 是 TJ 大神开发的小型调试模块.\n\n\n\n### 开发工具调试功能\n大型的开发 IDE 都会集成良好的调试工具. 目前主要的 Node.js 大型 IDE 有 Webstorm, Nodeclipse, Visual Studio. 他们都具有良好的调试能力. 具体的配置和使用方法可参看以下文章.\n\n* [使用神器webstorm调试nodejs](http://www.cnblogs.com/enix/archive/2012/04/29/2475983.html)\n* [在eclipse中追踪nodejs的数据，调试nodejs](http://www.myexception.cn/javascript/666602.html)\n* [eclipse 调试nodejs 发生Failed to connect to standalone V8 VM错误的解决方案](http://www.cnblogs.com/MrBackKom/archive/2012/06/11/2545684.html)\n* [Sublime Text 2调试NodeJS最方便的方法](http://www.douban.com/note/310794563/)\n* [joyent--Using Eclipse as Node Applications Debugger](https://github.com/joyent/node/wiki/using-eclipse-as-node-applications-debugger)  推荐\n* [node.js application debugging in Visual Studio](http://typescript.codeplex.com/workitem/512)\n* [Introducing node.js Tools for Visual Studio](http://www.hanselman.com/blog/IntroducingNodejsToolsForVisualStudio.aspx)\n* [webstorm 文档](http://www.jetbrains.com/webstorm/webhelp/running-and-debugging-node-js.html)\n\n\n### Joyent production practice\nJoyent 是 Node 的东家, 在他们的服务中也大量的用到了 Node 技术, 并把它们的使用事件分享了出来, 其中有关于调试一些内容大家可以参考 [Joyent practice](http://www.joyent.com/developers/node/debug)\n\n### 其他\nsupervisor, nodemon 等工具可以加快调试效率.\n\n### 总结\n也许 Node 调试起来没有 C, C++ 等语言更有效, 但可以使用的方法和工具也不少, 只要根据项目, 自身需求, 情况, 习惯使用即可.\n\n## 测试\n企业级应用或良好的模块, lib 都必须良好的测试, 甚至好多项目是由测试驱动如TDD, BDD. 这里要谈论的测试是由开发人员编写的单元测试, 或其他测试代码. 测试主要分为两类 功能测试(排除bug)和性能测试(查找性能瓶颈).\n\n### assert\nNode 提供了一个原生模块 `assert` 用于开发单元测试. 主要提供了数据判断的一些方法: fail, equal, notEqual ... 具体可参看[assert文档](http://nodejs.org/api/assert.html).\n\n### [mocha](http://visionmedia.github.io/mocha/)\nMocha 是 TJ 大神开发的测试模块, 也是目前 Node 社区最有名, 使用最多的测试框架. 具有众多优秀特点:\n\n* 支持浏览器, Node\n* 支持异步, 同步测试\n* 支持 TDD, BDD\n* 支持多种形式测试结果查看方式\n* 支持众多assertions: assert, should.js, chai, expect.js, better-assert\n* 提供命令行工具, 可以结合 make 或 grunt 使用\n\n关于具体的指导和文档可参看 [mocha](http://visionmedia.github.io/mocha/). 以及 Express, Koa 等知名模块的测试用例.\n\n### 其他单元测试模块\n除了 Mocha 还有许多测试框架, 比如 Isaac 的 tap, 还有[vows](http://vowsjs.org/). 详细列表可以访问[这里](https://nodejsmodules.org/tags/test)\n\n### 性能测试\n性能测试对于 Node 的主要应用场景 --- 高并发来说是非常重要的. 目前作者接触过 [wrk](https://github.com/wg/wrk). 由于对这块接触不多这里就不再详细介绍, 有兴趣的同学可以自己查找资料和技术.\n\n另外 [intern](http://theintern.io/) 是一个全新的测试平台, 有兴趣的同学可以尝试下.\n\n\n### 参考资料 \t\n* [webstorm unit test](https://www.jetbrains.com/webstorm/webhelp/unit-testing-node-js.html)\n* [Insanely fast, headless full-stack testing using Node.js](http://zombie.labnotes.org/)\n* [stackoverflow--unit test](http://stackoverflow.com/questions/7254025/node-js-unit-testing)\n\n\n#### 其他参考\n\n* [推荐几款非常不错的Node.js测试工具](http://www.csdn.net/article/2012-09-05/2809553)\n* [欲善其功，必先利其器--Nodejs调试技术总结](http://www.cnblogs.com/moonz-wu/archive/2012/01/15/2322120.html)\n* [nodejs 开发调试工具](http://www.oschina.net/question/35932_29983)\n* [elipse打造Nodejs的调试环境](http://blog.sina.com.cn/s/blog_72603eac0101567z.html)\n* [stackoverflow--How to debug node.js applications](http://stackoverflow.com/questions/1911015/how-to-debug-node-js-applications)   推荐\n* [nodejitsu.com -- How to debug a node application](http://docs.nodejitsu.com/articles/getting-started/how-to-debug-nodejs-applications)\n* [Debug NodeJS Like A Pro](http://greenido.wordpress.com/2013/08/27/debug-nodejs-like-a-pro/)\n* [Debugging node.js Projects](http://www.kevgriffin.com/debugging-node-js-projects/)\n* [How to debug a Node.js application in Windows Azure Web Sites](http://www.windowsazure.com/en-us/documentation/articles/web-sites-nodejs-debug/)\n* [cloud9--Running and Debugging Your Code](https://docs.c9.io/running_and_debugging_code.html)\n* [slide--nodejs debuging](http://www.slideshare.net/NicholasMcClay/nodejs-debugging)\n* [slide -- 单元测试实战](http://fengmk2.github.io/mk2blog/ppt/unittest-and-bdd-in-nodejs-with-mocha.deck.html)","source":"_posts/debug-test.md","raw":"title: Node.js企业开发 三调试&测试\ndate: 2014-01-15 22:55:36\ntags:\n---\n程序开发调试和测试是两个非常重要的环节, 在企业级应用开发中尤为重要.\n\n## 调试\n\n### console\n[console](http://nodejs.org/api/console.html) 想必是大家最熟悉, 使用最多的调试方法了, Node 的 console 模块为内置原生模块, 包含了一些基本方法(log, error, info, warn, dir, time, trace, assert)将变量输出到 std 流中. 可以实现最基本的调试功能.\n\n<!-- more -->\n\n### debugger\n[debugger](http://nodejs.org/api/debugger.html) 模块: V8 包含一个扩展调试器, 可以通过 TCP 协议在进程外访问, Node 包含一个内置的 debugger 客户端. 启动程序时添加 `debug` 参数可以启动.\n\n```% node debug myscript.js```\n\n该客户端没有实现所有功能, 但可以实现分步调试. 在代码中添加 `debugger;` 语句可以实现断点功能. \n还可以实现 watcher 功能, 具体使用方法可参看官方 API.\n\n### node-inspector\n\n[node-inspector](https://github.com/node-inspector/node-inspector) 是一个第三方模块, 是一个基于 Blink 开发工具的 Node.js 调试器. 通过 TCP 连接和 Node 程序通信, 实现调试功能. 跟浏览器中的 JS 调试工具有相同的功能, 通过该模块就能获的跟浏览器中相同的 JS 调试体验. 具体使用方法和步骤可以参看 [howtonode--Debugging with node-inspector](http://howtonode.org/debugging-with-node-inspector), [Taking Baby Steps with Node.js – Debugging with node-inspector](http://elegantcode.com/2011/01/14/taking-baby-steps-with-node-js-debugging-with-node-inspector/) 及 [node-inspector 百度经验](http://jingyan.baidu.com/article/dca1fa6fbd580ff1a44052de.html)\n\n另外 [debug](https://github.com/visionmedia/debug) 是 TJ 大神开发的小型调试模块.\n\n\n\n### 开发工具调试功能\n大型的开发 IDE 都会集成良好的调试工具. 目前主要的 Node.js 大型 IDE 有 Webstorm, Nodeclipse, Visual Studio. 他们都具有良好的调试能力. 具体的配置和使用方法可参看以下文章.\n\n* [使用神器webstorm调试nodejs](http://www.cnblogs.com/enix/archive/2012/04/29/2475983.html)\n* [在eclipse中追踪nodejs的数据，调试nodejs](http://www.myexception.cn/javascript/666602.html)\n* [eclipse 调试nodejs 发生Failed to connect to standalone V8 VM错误的解决方案](http://www.cnblogs.com/MrBackKom/archive/2012/06/11/2545684.html)\n* [Sublime Text 2调试NodeJS最方便的方法](http://www.douban.com/note/310794563/)\n* [joyent--Using Eclipse as Node Applications Debugger](https://github.com/joyent/node/wiki/using-eclipse-as-node-applications-debugger)  推荐\n* [node.js application debugging in Visual Studio](http://typescript.codeplex.com/workitem/512)\n* [Introducing node.js Tools for Visual Studio](http://www.hanselman.com/blog/IntroducingNodejsToolsForVisualStudio.aspx)\n* [webstorm 文档](http://www.jetbrains.com/webstorm/webhelp/running-and-debugging-node-js.html)\n\n\n### Joyent production practice\nJoyent 是 Node 的东家, 在他们的服务中也大量的用到了 Node 技术, 并把它们的使用事件分享了出来, 其中有关于调试一些内容大家可以参考 [Joyent practice](http://www.joyent.com/developers/node/debug)\n\n### 其他\nsupervisor, nodemon 等工具可以加快调试效率.\n\n### 总结\n也许 Node 调试起来没有 C, C++ 等语言更有效, 但可以使用的方法和工具也不少, 只要根据项目, 自身需求, 情况, 习惯使用即可.\n\n## 测试\n企业级应用或良好的模块, lib 都必须良好的测试, 甚至好多项目是由测试驱动如TDD, BDD. 这里要谈论的测试是由开发人员编写的单元测试, 或其他测试代码. 测试主要分为两类 功能测试(排除bug)和性能测试(查找性能瓶颈).\n\n### assert\nNode 提供了一个原生模块 `assert` 用于开发单元测试. 主要提供了数据判断的一些方法: fail, equal, notEqual ... 具体可参看[assert文档](http://nodejs.org/api/assert.html).\n\n### [mocha](http://visionmedia.github.io/mocha/)\nMocha 是 TJ 大神开发的测试模块, 也是目前 Node 社区最有名, 使用最多的测试框架. 具有众多优秀特点:\n\n* 支持浏览器, Node\n* 支持异步, 同步测试\n* 支持 TDD, BDD\n* 支持多种形式测试结果查看方式\n* 支持众多assertions: assert, should.js, chai, expect.js, better-assert\n* 提供命令行工具, 可以结合 make 或 grunt 使用\n\n关于具体的指导和文档可参看 [mocha](http://visionmedia.github.io/mocha/). 以及 Express, Koa 等知名模块的测试用例.\n\n### 其他单元测试模块\n除了 Mocha 还有许多测试框架, 比如 Isaac 的 tap, 还有[vows](http://vowsjs.org/). 详细列表可以访问[这里](https://nodejsmodules.org/tags/test)\n\n### 性能测试\n性能测试对于 Node 的主要应用场景 --- 高并发来说是非常重要的. 目前作者接触过 [wrk](https://github.com/wg/wrk). 由于对这块接触不多这里就不再详细介绍, 有兴趣的同学可以自己查找资料和技术.\n\n另外 [intern](http://theintern.io/) 是一个全新的测试平台, 有兴趣的同学可以尝试下.\n\n\n### 参考资料 \t\n* [webstorm unit test](https://www.jetbrains.com/webstorm/webhelp/unit-testing-node-js.html)\n* [Insanely fast, headless full-stack testing using Node.js](http://zombie.labnotes.org/)\n* [stackoverflow--unit test](http://stackoverflow.com/questions/7254025/node-js-unit-testing)\n\n\n#### 其他参考\n\n* [推荐几款非常不错的Node.js测试工具](http://www.csdn.net/article/2012-09-05/2809553)\n* [欲善其功，必先利其器--Nodejs调试技术总结](http://www.cnblogs.com/moonz-wu/archive/2012/01/15/2322120.html)\n* [nodejs 开发调试工具](http://www.oschina.net/question/35932_29983)\n* [elipse打造Nodejs的调试环境](http://blog.sina.com.cn/s/blog_72603eac0101567z.html)\n* [stackoverflow--How to debug node.js applications](http://stackoverflow.com/questions/1911015/how-to-debug-node-js-applications)   推荐\n* [nodejitsu.com -- How to debug a node application](http://docs.nodejitsu.com/articles/getting-started/how-to-debug-nodejs-applications)\n* [Debug NodeJS Like A Pro](http://greenido.wordpress.com/2013/08/27/debug-nodejs-like-a-pro/)\n* [Debugging node.js Projects](http://www.kevgriffin.com/debugging-node-js-projects/)\n* [How to debug a Node.js application in Windows Azure Web Sites](http://www.windowsazure.com/en-us/documentation/articles/web-sites-nodejs-debug/)\n* [cloud9--Running and Debugging Your Code](https://docs.c9.io/running_and_debugging_code.html)\n* [slide--nodejs debuging](http://www.slideshare.net/NicholasMcClay/nodejs-debugging)\n* [slide -- 单元测试实战](http://fengmk2.github.io/mk2blog/ppt/unittest-and-bdd-in-nodejs-with-mocha.deck.html)","slug":"debug-test","published":1,"updated":"2015-10-12T04:34:15.000Z","_id":"cifmere1r001lvs1mywiuv8jl","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js流程控制","date":"2013-11-13T01:41:12.000Z","_content":"Node.js通过回调实现非阻塞从而达到超高性能, 但回调大大增加了流程控制的复杂度, 一直为广大JS程序员所诟病, 甚至将许多开发者挡在了大门之外. 虽然目前回调方式不可避免, 但有许多解决方案可以大大简化回调开发难度.\n\n目前常见的解决方案可归为如下几类:\n\n* Node官方使用方式: 回调作为最后一个参数传递, 回调的第一个参数为error\n* promise\n* ES6 generator\n* 第三方module: async, step, wind.js, eventproxy\n\n<!-- more -->\n\n## Node官方回调方式\n在早期的Node版本中曾经使用promise的回调方式, 后来被放弃了. 目前使用的方式为回调函数做为方法最后一个参数传递\n, 回调函数的第一个参数为error, 正常则为null, 其他参数为传回的数据\n\n\n## promise\npromise是CommonJS提出的一种异步实现方式, 在CommonJS的[wiki](http://wiki.commonjs.org/wiki/Promises)中有对promise的详细解释.\n微软现在win8 JS app SDK就使用了promise回调模式. 目前有多个promise库可供大家使用\n\n* [Q](https://github.com/kriskowal/q) by Kris Kowal\n* [Promised-IO](https://github.com/kriszyp/promised-io) by Kriz Zyp\n\n关于promise的具体内容可参看howtonode 的一篇博客 [promise](http://howtonode.org/promises)以及infoq的[介绍](http://www.infoq.com/cn/news/2011/09/js-promise)\n\n\n## ES6 generator\ngenerator是ES6的一个新特性, yield调用代码块, 将会给回调带来方便\n\n* [官方wiki](http://wiki.ecmascript.org/doku.php?id=harmony:generators)\n* [Javascript's Future: Generators](http://jlongster.com/2012/10/05/javascript-yield.html)\n* [whats the big deal with generators](http://devsmash.com/blog/whats-the-big-deal-with-generators)\n\n## 第三方库\nNode.js目前有很多流程控制的module\n\n* [async](https://github.com/caolan/async)\n* [step](https://github.com/creationix/step)\n* [wind.js](http://windjs.org/cn/)\n* [eventproxy](https://github.com/JacksonTian/eventproxy)\n\n其中async module是npm依赖排行榜第二名, 仅落后于underscore, 个人也非常推荐使用该库, 具体使用方式可参看官方文档和[async使用实战](http://www.sebastianseilund.com/nodejs-async-in-practice)\n这篇博客, 另外async使用named function 对tracking error有帮助.\n\n## 常见的流程模式\n\n* Series\n* Fully parallel\n* Limitedly parallel\n\n\n\n参考:\n\n* [howtonode -- promiese](http://howtonode.org/promises)\n* [howtonode -- control flow](http://howtonode.org/control-flow)\n* [howtonode -- control flow ii](http://howtonode.org/control-flow-part-ii)\n* [Mixu's node book -- control flow](http://book.mixu.net/node/ch7.html)\n* [流程控制模块](https://nodejsmodules.org/tags/flow)\n* [async使用实战](http://www.sebastianseilund.com/nodejs-async-in-practice)\n","source":"_posts/control_flow.md","raw":"title: Node.js流程控制\ndate: 2013-11-13 09:41:12\ntags:\n---\nNode.js通过回调实现非阻塞从而达到超高性能, 但回调大大增加了流程控制的复杂度, 一直为广大JS程序员所诟病, 甚至将许多开发者挡在了大门之外. 虽然目前回调方式不可避免, 但有许多解决方案可以大大简化回调开发难度.\n\n目前常见的解决方案可归为如下几类:\n\n* Node官方使用方式: 回调作为最后一个参数传递, 回调的第一个参数为error\n* promise\n* ES6 generator\n* 第三方module: async, step, wind.js, eventproxy\n\n<!-- more -->\n\n## Node官方回调方式\n在早期的Node版本中曾经使用promise的回调方式, 后来被放弃了. 目前使用的方式为回调函数做为方法最后一个参数传递\n, 回调函数的第一个参数为error, 正常则为null, 其他参数为传回的数据\n\n\n## promise\npromise是CommonJS提出的一种异步实现方式, 在CommonJS的[wiki](http://wiki.commonjs.org/wiki/Promises)中有对promise的详细解释.\n微软现在win8 JS app SDK就使用了promise回调模式. 目前有多个promise库可供大家使用\n\n* [Q](https://github.com/kriskowal/q) by Kris Kowal\n* [Promised-IO](https://github.com/kriszyp/promised-io) by Kriz Zyp\n\n关于promise的具体内容可参看howtonode 的一篇博客 [promise](http://howtonode.org/promises)以及infoq的[介绍](http://www.infoq.com/cn/news/2011/09/js-promise)\n\n\n## ES6 generator\ngenerator是ES6的一个新特性, yield调用代码块, 将会给回调带来方便\n\n* [官方wiki](http://wiki.ecmascript.org/doku.php?id=harmony:generators)\n* [Javascript's Future: Generators](http://jlongster.com/2012/10/05/javascript-yield.html)\n* [whats the big deal with generators](http://devsmash.com/blog/whats-the-big-deal-with-generators)\n\n## 第三方库\nNode.js目前有很多流程控制的module\n\n* [async](https://github.com/caolan/async)\n* [step](https://github.com/creationix/step)\n* [wind.js](http://windjs.org/cn/)\n* [eventproxy](https://github.com/JacksonTian/eventproxy)\n\n其中async module是npm依赖排行榜第二名, 仅落后于underscore, 个人也非常推荐使用该库, 具体使用方式可参看官方文档和[async使用实战](http://www.sebastianseilund.com/nodejs-async-in-practice)\n这篇博客, 另外async使用named function 对tracking error有帮助.\n\n## 常见的流程模式\n\n* Series\n* Fully parallel\n* Limitedly parallel\n\n\n\n参考:\n\n* [howtonode -- promiese](http://howtonode.org/promises)\n* [howtonode -- control flow](http://howtonode.org/control-flow)\n* [howtonode -- control flow ii](http://howtonode.org/control-flow-part-ii)\n* [Mixu's node book -- control flow](http://book.mixu.net/node/ch7.html)\n* [流程控制模块](https://nodejsmodules.org/tags/flow)\n* [async使用实战](http://www.sebastianseilund.com/nodejs-async-in-practice)\n","slug":"control_flow","published":1,"updated":"2015-10-12T04:34:29.000Z","_id":"cifmere1s001mvs1mqi3hhetf","comments":1,"layout":"post","photos":[],"link":""},{"title":"CoffeeScript","date":"2013-10-09T13:51:34.000Z","_content":"\n[CoffeeScript](http://coffeescript.org/)的实际意义是允许使用Ruby/Python的更优语法开发JS代码. JS语言本身有good parts和坏的部分(全局变量声明, with等), CoffeeScript的目标是使用一种简单的方式暴露JS的good parts\n\n<!-- more -->\n\n## About coffeescript\n\n* 使用Coffeescript开发\n* Golden rule: 'It's just JavaScript'\n* 同直接使用JS开发的同等代码相比有更高的执行效率\n* 能在所有的JavaScript runtime 执行: 所有浏览器, node\n* command-line version coffee 是一个Node.js utility, 包含compiler和REPL, 使用npm安装 `npm install -g coffee-script`, 同时包含一个build system cake\n\n\n## Features (coffee has a ruby like grammer):\n\n* 使用有意义的空白符界定代码块, 抛弃{}\n* 变量作用域自动管理, 不需要 var\n* 换行作为表达式的结束, 不需要 ;\n* 方法调用可省略()\n* 变量对象定义, 换行处无需 ,\n* 变量定义可省略 {}\n* 灵活的条件语句: if else then until unless\n* 方法定义支持默认参数\n* 方法定义调用支持不定量参数\n* 方便的循环和迭代\n* 支持range\n* everything is expression\n* 定义操作符的单词行alias: is isnt not and or true yes on false no off @ this of in\n* 存在操作符 ?\n* 方便的类定义形式: Class, Inheritance, Super\n* Function binding\n* Destructuring Assignment\n\n\n## coffee grammer\n\n* Functions\n* Objects and Arrays\n* Lexical Scoping and Variable Safety\n* If, Else, Unless, and Conditional Assignment\n* Splats…\n* Loops and Comprehensions\n* Array Slicing and Splicing with Ranges\n* Everything is an Expression(at least, as much as possible)\n* Operators and Aliases\n* The Existential Operator\n* Classses, Inheritance, and Super\n* Destructuring Assignment\n* Function binding\n* Embedded Javascript\n* Switch/When/Else\n* Try/Catch/Finally\n* Chained Comparisons\n* String Interpolation, Block Strings, and Block Comments\n* Block Regular Expressions\n\n\n\n\n## 学习目标\n\n1. 学习并灵活使用coffee支持的所有语法\n2. 知道coffee代码的转换规则\n\n\n更多内容参看[coffeescript](http://coffeescript.org/), 包含coffeescript的特点, 前世今生, 安装, 语法, books, screencasts, exmaples, resources, annotated source, 交互终端\n\n个人推荐Node.js开发的同学使用. 后端开发不涉及dom操作, 使用coffee开发应该能加快开发效率, 提升代码执行效率.\n\n[LiveScript](http://livescript.net/)跟coffee有点类似,也是支持使用全新的语法开发JS.\n\n[TypeScript](http://www.typescriptlang.org/)是微软开发的可扩展语言, 适用于开发大型JS程序.\n","source":"_posts/coffeescript.md","raw":"title:  CoffeeScript\ndate: 2013-10-09 21:51:34\ntags: coffeescript\n---\n\n[CoffeeScript](http://coffeescript.org/)的实际意义是允许使用Ruby/Python的更优语法开发JS代码. JS语言本身有good parts和坏的部分(全局变量声明, with等), CoffeeScript的目标是使用一种简单的方式暴露JS的good parts\n\n<!-- more -->\n\n## About coffeescript\n\n* 使用Coffeescript开发\n* Golden rule: 'It's just JavaScript'\n* 同直接使用JS开发的同等代码相比有更高的执行效率\n* 能在所有的JavaScript runtime 执行: 所有浏览器, node\n* command-line version coffee 是一个Node.js utility, 包含compiler和REPL, 使用npm安装 `npm install -g coffee-script`, 同时包含一个build system cake\n\n\n## Features (coffee has a ruby like grammer):\n\n* 使用有意义的空白符界定代码块, 抛弃{}\n* 变量作用域自动管理, 不需要 var\n* 换行作为表达式的结束, 不需要 ;\n* 方法调用可省略()\n* 变量对象定义, 换行处无需 ,\n* 变量定义可省略 {}\n* 灵活的条件语句: if else then until unless\n* 方法定义支持默认参数\n* 方法定义调用支持不定量参数\n* 方便的循环和迭代\n* 支持range\n* everything is expression\n* 定义操作符的单词行alias: is isnt not and or true yes on false no off @ this of in\n* 存在操作符 ?\n* 方便的类定义形式: Class, Inheritance, Super\n* Function binding\n* Destructuring Assignment\n\n\n## coffee grammer\n\n* Functions\n* Objects and Arrays\n* Lexical Scoping and Variable Safety\n* If, Else, Unless, and Conditional Assignment\n* Splats…\n* Loops and Comprehensions\n* Array Slicing and Splicing with Ranges\n* Everything is an Expression(at least, as much as possible)\n* Operators and Aliases\n* The Existential Operator\n* Classses, Inheritance, and Super\n* Destructuring Assignment\n* Function binding\n* Embedded Javascript\n* Switch/When/Else\n* Try/Catch/Finally\n* Chained Comparisons\n* String Interpolation, Block Strings, and Block Comments\n* Block Regular Expressions\n\n\n\n\n## 学习目标\n\n1. 学习并灵活使用coffee支持的所有语法\n2. 知道coffee代码的转换规则\n\n\n更多内容参看[coffeescript](http://coffeescript.org/), 包含coffeescript的特点, 前世今生, 安装, 语法, books, screencasts, exmaples, resources, annotated source, 交互终端\n\n个人推荐Node.js开发的同学使用. 后端开发不涉及dom操作, 使用coffee开发应该能加快开发效率, 提升代码执行效率.\n\n[LiveScript](http://livescript.net/)跟coffee有点类似,也是支持使用全新的语法开发JS.\n\n[TypeScript](http://www.typescriptlang.org/)是微软开发的可扩展语言, 适用于开发大型JS程序.\n","slug":"coffeescript","published":1,"updated":"2015-10-12T04:34:33.000Z","_id":"cifmere1w001nvs1ma0kebly0","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js在中国","date":"2013-09-27T06:29:34.000Z","_content":"N发展迅速, 在中国也有大量的N粉, 开发者. 并且诞生一些优秀的项目, 许多大公司都开始采用N.\n\n## 优秀项目\n\n### [Node-Webkit](https://github.com/rogerwang/node-webkit)\n基于Chromium与Node.js的应用程序运行器，允许开发者使用web技术编写桌面应用程序。在英特尔的开源技术中心创建和发展起来的。\n\n<!-- more -->\n\n* 可以用HTML5、CSS3、JS和WebGL写应用\n* 完全支持Node.js的API以及它的所有第三方模块\n* 性能好：Node和WebKit运行在同一个线程内，函数调用简单，对象也在同一个堆上，可以与相引用\n* 容易打包和发布应用\n* 跨平台运行，兼容Linux、Mac OSX和Windows\n\n该项目使得N及Web技术开发桌面程序(兼容三大平台), 大大扩展N的应用范围. 是Github上关注最高的N第三方应用.\n在启动一年之后，node-webkit从一个默默无闻的项目成功跻身GitHub C++项目关注度排行榜前五强。\n\n### [Pomelo](http://pomelo.netease.com/)\nPomelo是网易开发的N的游戏服务器框架, fast, scalable. 它提供基础开发框架, 相关模块, 库和工具. \n并且适用与real-time web应用开发它的分布式架构使得pomelo比其他实时web框架更容易scale.\n目前pomelo在网易,以及一些web游戏中得到应用.\n\n* 快速,可扩展\n    1. 分布式架构\n    2. 灵活的服务器扩展\n    3. 全面性能优化和扩展\n* 简单\n    1. API简单: request, response, broadcast, etc.\n    2. 轻量: 基于node.js的高开发效率\n    3. 惯例重于配置: 几乎没有配置\n* 强大\n    1. 众多库和工具\n    2. 文档丰富完善\n\n\n\n### [Clouda](http://cloudajs.org/)\nClouda是百度开发的实时Javascript开发框架, BAE3.0完全支持.\n\n* 云端统一: 只用Javascript一门语言，抹平云端界限，一份代码处处运行。\n* 实时编程: 所有数据实时推送的基础设置，每个终端都无延迟同步响应。\n* 随动反馈: 面向数据的编程模型，数据实时推送后，界面会自动更新。\n* 一键托管: 无缝整合百度BAE云环境，即可自建服务器也可一键托管在百度云。\n* 转为移动: 为智能手机与平板电脑特别设计，运行性能高，标配离线能力。\n* 高兼容性: 标配数据同步工具，兼容已有服务；同时兼容Backbone等开源框架。\n* SEO能力: 原厂匹配主流搜索引擎，每个APP场景都可以被搜索引擎爬虫抓取。\n* 入门简单: 简单语法搭配丰富教程与文档，保证快速上手，还配有5分钟教程\n\nClouda伴随BAE3.0推出, BAE部署非常简单, 适用移动web app开发.\n\n\n## 知名开发者\n\n### [朴灵](http://html5ify.com/)\n原名田永强, 阿里巴巴JS开发者, 从N早期就开始关注,尝试,推广. 写了许多N相关博客(深入浅出Node.js), 书籍, 模块.\n在国内的许多技术大会上担任N的讲师和主持, 被誉为中国Node.js布道者.\n\n### [Rogerwang](https://github.com/rogerwang)\n王文睿，英特尔开放源码技术中心（OTC）的软件架构师。最开始，node-webkit是一个业余项目。\n现在，Roger可以在工作时间进行这个项目的开发，而且有一个实习生跟他一起工作。\n\n### [谢骋超](http://my.oschina.net/xiecc)\nPomelo框架的发起人和主要负责人.\n\n\n\n## 使用&支持情况\n\n* 阿里巴巴\n* 百度\n* 小米\n* 高德\n* 七牛云存储\n\n\n\n","source":"_posts/china_developer_work.md","raw":"title: Node.js在中国\ndate: 2013-09-27 14:29:34\ntags: 国内\n---\nN发展迅速, 在中国也有大量的N粉, 开发者. 并且诞生一些优秀的项目, 许多大公司都开始采用N.\n\n## 优秀项目\n\n### [Node-Webkit](https://github.com/rogerwang/node-webkit)\n基于Chromium与Node.js的应用程序运行器，允许开发者使用web技术编写桌面应用程序。在英特尔的开源技术中心创建和发展起来的。\n\n<!-- more -->\n\n* 可以用HTML5、CSS3、JS和WebGL写应用\n* 完全支持Node.js的API以及它的所有第三方模块\n* 性能好：Node和WebKit运行在同一个线程内，函数调用简单，对象也在同一个堆上，可以与相引用\n* 容易打包和发布应用\n* 跨平台运行，兼容Linux、Mac OSX和Windows\n\n该项目使得N及Web技术开发桌面程序(兼容三大平台), 大大扩展N的应用范围. 是Github上关注最高的N第三方应用.\n在启动一年之后，node-webkit从一个默默无闻的项目成功跻身GitHub C++项目关注度排行榜前五强。\n\n### [Pomelo](http://pomelo.netease.com/)\nPomelo是网易开发的N的游戏服务器框架, fast, scalable. 它提供基础开发框架, 相关模块, 库和工具. \n并且适用与real-time web应用开发它的分布式架构使得pomelo比其他实时web框架更容易scale.\n目前pomelo在网易,以及一些web游戏中得到应用.\n\n* 快速,可扩展\n    1. 分布式架构\n    2. 灵活的服务器扩展\n    3. 全面性能优化和扩展\n* 简单\n    1. API简单: request, response, broadcast, etc.\n    2. 轻量: 基于node.js的高开发效率\n    3. 惯例重于配置: 几乎没有配置\n* 强大\n    1. 众多库和工具\n    2. 文档丰富完善\n\n\n\n### [Clouda](http://cloudajs.org/)\nClouda是百度开发的实时Javascript开发框架, BAE3.0完全支持.\n\n* 云端统一: 只用Javascript一门语言，抹平云端界限，一份代码处处运行。\n* 实时编程: 所有数据实时推送的基础设置，每个终端都无延迟同步响应。\n* 随动反馈: 面向数据的编程模型，数据实时推送后，界面会自动更新。\n* 一键托管: 无缝整合百度BAE云环境，即可自建服务器也可一键托管在百度云。\n* 转为移动: 为智能手机与平板电脑特别设计，运行性能高，标配离线能力。\n* 高兼容性: 标配数据同步工具，兼容已有服务；同时兼容Backbone等开源框架。\n* SEO能力: 原厂匹配主流搜索引擎，每个APP场景都可以被搜索引擎爬虫抓取。\n* 入门简单: 简单语法搭配丰富教程与文档，保证快速上手，还配有5分钟教程\n\nClouda伴随BAE3.0推出, BAE部署非常简单, 适用移动web app开发.\n\n\n## 知名开发者\n\n### [朴灵](http://html5ify.com/)\n原名田永强, 阿里巴巴JS开发者, 从N早期就开始关注,尝试,推广. 写了许多N相关博客(深入浅出Node.js), 书籍, 模块.\n在国内的许多技术大会上担任N的讲师和主持, 被誉为中国Node.js布道者.\n\n### [Rogerwang](https://github.com/rogerwang)\n王文睿，英特尔开放源码技术中心（OTC）的软件架构师。最开始，node-webkit是一个业余项目。\n现在，Roger可以在工作时间进行这个项目的开发，而且有一个实习生跟他一起工作。\n\n### [谢骋超](http://my.oschina.net/xiecc)\nPomelo框架的发起人和主要负责人.\n\n\n\n## 使用&支持情况\n\n* 阿里巴巴\n* 百度\n* 小米\n* 高德\n* 七牛云存储\n\n\n\n","slug":"china_developer_work","published":1,"updated":"2015-10-12T04:34:41.000Z","_id":"cifmere1z001qvs1mog3m1879","comments":1,"layout":"post","photos":[],"link":""},{"title":"Node.js企业开发 四正式环境部署","date":"2014-01-25T02:24:15.000Z","_content":"Node 应用开发完成之后的工作就是应用部署了. \n\n## 测试环境, 预发布环境\n企业级应用开发除了单元测试代码不可缺少之外, 通常还会部署多个环境保证最终服务的正确无误.\n通常开发阶段会有`开发环境`, `调试环境`, 部署之前有`测试环境`, `预发布环境`, 以及`正式环境`又叫`产品环境`.\n\n测试环境通常是给测试人员进行功能测试, 确保开发程序的所有功能是否Ok, 是否满足需求. 当在测试环境监测通过后应该就可以向正式环境部署了, 但测试环境的数据环境通常同正式环境会有很大差别, 所以很多企业还会有预发布环境用于排除数据或访问量带来的问题\n\n<!-- more -->\n\n## cluster\nNode 单线程的架构没法充分利用当前服务器的多核 CPU 性能, 因此 Node.js 提供了原生的[cluster](http://nodejs.org/api/cluster.html)模块, 可以充分利用多核CPU的性能, 同时可以增加程序的稳定性.\n\ncluster 使用例子: \n\n```\nvar cluster = require('cluster');\nvar http = require('http');\nvar numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  // Fork workers.\n  for (var i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', function(worker, code, signal) {\n    console.log('worker ' + worker.process.pid + ' died');\n  });\n} else {\n  // Workers can share any TCP connection\n  // In this case its a HTTP server\n  http.createServer(function(req, res) {\n    res.writeHead(200);\n    res.end(\"hello world\\n\");\n  }).listen(8000);\n}\n```\n\n\n## &, nohup, forever, pm2\n#### 后台执行\nNode 服务进程通常需要在后台运行, 可以使用 linux 系统的后台命令, 也可以使用比较成熟的 module 使用.\n\n```\n$ nohup node app.js &\n```\n这样程序将会在后台执行.\n\n#### 进程守护\n正式环境一般都会对服务进程添加守护, Node 社区目前比较成熟的有 [forever](https://github.com/nodejitsu/forever) 和 [pm2](https://github.com/Unitech/pm2)\n\nforever 是最早的进程守护工具, 可以以 CLI 或编码的形式使用.\n\n全局安装forever\n\n\t$ npm install -g forever\n\t\n使用 forever 启动服务\n\n\t$ forever start app.js\n\t\nforever 还可以记录服务运行日志及错误日志, 具体方法可参看 [github](https://github.com/nodejitsu/forever)文档\n\n`pm2` 是全新开发的进程守护服务, 同时集成了负载均衡功能. 以及开机启动, 自动重启有问题进程. [pm2](http://signup.pm2.io/) 还可以查看各服务进程状态. 国外许多开发者认为 [pm2 比 forever 更优](http://devo.ps/blog/2013/06/26/goodbye-node-forever-hello-pm2.html)\n\npm2 命令方法与 forever 类似, 首先需要全局安装:\n\n\t$ npm install pm2@latest -g\n\t\n然后使用 pm2 启动服务\n\n\t$ pm2 start app.js -i 4\n\t$ pm2 monit    #监控服务\n\t\n关于详细使用方法可以参看 [官方文档](https://github.com/Unitech/pm2)\n\n## nginx\nnginx 是俄罗斯程序员开发的全新高性能web server, 其运行原理同 node 类似, 也是基于事件的机制, 但它是一个server 软件, 功能与 Apache 类似, 最近几年许多大型网站开始使用 nginx. Node.js 本身并不适合服务静态文件, 所以可以使用nginx同 node.js 结合使用, Node.js 处理业务逻辑, nginx 服务静态文件.\n\n```\nserver {\n\tlisten 80;\n    server_name domain.serve.com;\n    access_log  /var/log/logfile.log main;\n    root /opt/application_path;\n\n    location / {\n    \tproxy_set_header Host $host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://127.0.0.1:3000;\n    }\n\n    location ~* \\.(jpg|jpeg|gif|css|png|js|ico)$ {\n    \taccess_log off;\n        expires 7d;\n    }\n}\n```\n以上为最简单的nginx配置, 他会将具体的业务需求转给 node 处理. 还有其他配置方式和更加详细的优化可以参看网络资料.\n\n* [为高负载网络优化Nginx和Node.js](http://developer.51cto.com/art/201301/378571.htm)\n* [Node.js与Nginx](http://ittechnical.sinaapp.com/node-js-and-nginx/)\n* [node.js 与 nginx配合使用](http://hi.baidu.com/guoxiaoming/item/1074554ab504feaddf2a9fb3)\n* [Node.js部署最佳实践](http://www.douban.com/note/265207425/)\n\n## 日志\nweb 服务记录访问和错误日志是必要工作, 最常使用的日志记录方式为文件日志(也可以使用数据库存储日志). 在 Node 中记录日志方式可以有多种:\n\n* Nginx 或 Apache\n* forever, pm2\n* 日志module: log4js, winston\n\n如 `log4js` 记录日志方法:\n\n```\nvar log4js = require('log4js'); \n//console log is loaded by default, so you won't normally need to do this\n//log4js.loadAppender('console');\nlog4js.loadAppender('file');\n//log4js.addAppender(log4js.appenders.console());\nlog4js.addAppender(log4js.appenders.file('logs/cheese.log'), 'cheese');\n\nvar logger = log4js.getLogger('cheese');\nlogger.setLevel('ERROR');\n\nlogger.trace('Entering cheese testing');\nlogger.debug('Got cheese.');\nlogger.info('Cheese is Gouda.');\nlogger.warn('Cheese is quite smelly.');\nlogger.error('Cheese is too ripe!');\nlogger.fatal('Cheese was breeding ground for listeria.');\n```\n\n日志对于访问统计和错误处理非常有用, 正式环境的日志记录有许多规范方法和经验(如日志分离)具体可以到网上查找.\n\n\n## 提醒\n正式服务通常都会有提醒服务, 当服务down掉, 或者有错误时会向运维人员或维护人员发送提醒服务, 通常的提醒方式有: 邮件, IM, 短信等. 具体实现方法可以自己研究查看.\n\n\n\n\n### 参考\n\n* [how-to-deploy-node-to-production](http://www.slideshare.net/embwbam/how-to-deploy-node-to-production)\n* [stackoverflow-Node.js Production Deployment](http://stackoverflow.com/questions/15971156/node-js-production-deployment)\n* [stackoverflow-Deploying a production Node.js server](http://stackoverflow.com/questions/8386455/deploying-a-production-node-js-server)\n* [DEPLOYING NODE.JS TO PRODUCTION](http://codeplease.wordpress.com/2013/09/27/deploying-node-js-production/)\n* [HARDENING NODE.JS FOR PRODUCTION: A PROCESS SUPERVISOR](http://blog.argteam.com/coding/hardening-nodejs-production-process-supervisor/)\n* [book-How to Deploy a Node.js App to Production](http://fluentconf.com/fluent2012/public/schedule/detail/24643)\n* [Joyent-Production Practices-deploy](http://www.joyent.com/developers/node/deploy)\n* [Node.js deployment in production settings](http://ngo-hung.com/blog/2012/07/14/node-js-deployment-in-production-settings)\n* [Setup node.js Servers Within a Load-balanced Configuration](http://shawn.dahlen.me/blog/2013/03/18/setup-node-dot-js-servers-within-a-load-balanced-configuration/)\n* [Nodejs Production Deployment](http://cthayer.wordpress.com/2013/11/05/nodejs-production-deployment/)\n* [https://node.ci](https://node.ci/)","source":"_posts/application_deploy.md","raw":"title: Node.js企业开发 四正式环境部署\ndate: 2014-01-25 10:24:15\ntags:\n---\nNode 应用开发完成之后的工作就是应用部署了. \n\n## 测试环境, 预发布环境\n企业级应用开发除了单元测试代码不可缺少之外, 通常还会部署多个环境保证最终服务的正确无误.\n通常开发阶段会有`开发环境`, `调试环境`, 部署之前有`测试环境`, `预发布环境`, 以及`正式环境`又叫`产品环境`.\n\n测试环境通常是给测试人员进行功能测试, 确保开发程序的所有功能是否Ok, 是否满足需求. 当在测试环境监测通过后应该就可以向正式环境部署了, 但测试环境的数据环境通常同正式环境会有很大差别, 所以很多企业还会有预发布环境用于排除数据或访问量带来的问题\n\n<!-- more -->\n\n## cluster\nNode 单线程的架构没法充分利用当前服务器的多核 CPU 性能, 因此 Node.js 提供了原生的[cluster](http://nodejs.org/api/cluster.html)模块, 可以充分利用多核CPU的性能, 同时可以增加程序的稳定性.\n\ncluster 使用例子: \n\n```\nvar cluster = require('cluster');\nvar http = require('http');\nvar numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  // Fork workers.\n  for (var i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', function(worker, code, signal) {\n    console.log('worker ' + worker.process.pid + ' died');\n  });\n} else {\n  // Workers can share any TCP connection\n  // In this case its a HTTP server\n  http.createServer(function(req, res) {\n    res.writeHead(200);\n    res.end(\"hello world\\n\");\n  }).listen(8000);\n}\n```\n\n\n## &, nohup, forever, pm2\n#### 后台执行\nNode 服务进程通常需要在后台运行, 可以使用 linux 系统的后台命令, 也可以使用比较成熟的 module 使用.\n\n```\n$ nohup node app.js &\n```\n这样程序将会在后台执行.\n\n#### 进程守护\n正式环境一般都会对服务进程添加守护, Node 社区目前比较成熟的有 [forever](https://github.com/nodejitsu/forever) 和 [pm2](https://github.com/Unitech/pm2)\n\nforever 是最早的进程守护工具, 可以以 CLI 或编码的形式使用.\n\n全局安装forever\n\n\t$ npm install -g forever\n\t\n使用 forever 启动服务\n\n\t$ forever start app.js\n\t\nforever 还可以记录服务运行日志及错误日志, 具体方法可参看 [github](https://github.com/nodejitsu/forever)文档\n\n`pm2` 是全新开发的进程守护服务, 同时集成了负载均衡功能. 以及开机启动, 自动重启有问题进程. [pm2](http://signup.pm2.io/) 还可以查看各服务进程状态. 国外许多开发者认为 [pm2 比 forever 更优](http://devo.ps/blog/2013/06/26/goodbye-node-forever-hello-pm2.html)\n\npm2 命令方法与 forever 类似, 首先需要全局安装:\n\n\t$ npm install pm2@latest -g\n\t\n然后使用 pm2 启动服务\n\n\t$ pm2 start app.js -i 4\n\t$ pm2 monit    #监控服务\n\t\n关于详细使用方法可以参看 [官方文档](https://github.com/Unitech/pm2)\n\n## nginx\nnginx 是俄罗斯程序员开发的全新高性能web server, 其运行原理同 node 类似, 也是基于事件的机制, 但它是一个server 软件, 功能与 Apache 类似, 最近几年许多大型网站开始使用 nginx. Node.js 本身并不适合服务静态文件, 所以可以使用nginx同 node.js 结合使用, Node.js 处理业务逻辑, nginx 服务静态文件.\n\n```\nserver {\n\tlisten 80;\n    server_name domain.serve.com;\n    access_log  /var/log/logfile.log main;\n    root /opt/application_path;\n\n    location / {\n    \tproxy_set_header Host $host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://127.0.0.1:3000;\n    }\n\n    location ~* \\.(jpg|jpeg|gif|css|png|js|ico)$ {\n    \taccess_log off;\n        expires 7d;\n    }\n}\n```\n以上为最简单的nginx配置, 他会将具体的业务需求转给 node 处理. 还有其他配置方式和更加详细的优化可以参看网络资料.\n\n* [为高负载网络优化Nginx和Node.js](http://developer.51cto.com/art/201301/378571.htm)\n* [Node.js与Nginx](http://ittechnical.sinaapp.com/node-js-and-nginx/)\n* [node.js 与 nginx配合使用](http://hi.baidu.com/guoxiaoming/item/1074554ab504feaddf2a9fb3)\n* [Node.js部署最佳实践](http://www.douban.com/note/265207425/)\n\n## 日志\nweb 服务记录访问和错误日志是必要工作, 最常使用的日志记录方式为文件日志(也可以使用数据库存储日志). 在 Node 中记录日志方式可以有多种:\n\n* Nginx 或 Apache\n* forever, pm2\n* 日志module: log4js, winston\n\n如 `log4js` 记录日志方法:\n\n```\nvar log4js = require('log4js'); \n//console log is loaded by default, so you won't normally need to do this\n//log4js.loadAppender('console');\nlog4js.loadAppender('file');\n//log4js.addAppender(log4js.appenders.console());\nlog4js.addAppender(log4js.appenders.file('logs/cheese.log'), 'cheese');\n\nvar logger = log4js.getLogger('cheese');\nlogger.setLevel('ERROR');\n\nlogger.trace('Entering cheese testing');\nlogger.debug('Got cheese.');\nlogger.info('Cheese is Gouda.');\nlogger.warn('Cheese is quite smelly.');\nlogger.error('Cheese is too ripe!');\nlogger.fatal('Cheese was breeding ground for listeria.');\n```\n\n日志对于访问统计和错误处理非常有用, 正式环境的日志记录有许多规范方法和经验(如日志分离)具体可以到网上查找.\n\n\n## 提醒\n正式服务通常都会有提醒服务, 当服务down掉, 或者有错误时会向运维人员或维护人员发送提醒服务, 通常的提醒方式有: 邮件, IM, 短信等. 具体实现方法可以自己研究查看.\n\n\n\n\n### 参考\n\n* [how-to-deploy-node-to-production](http://www.slideshare.net/embwbam/how-to-deploy-node-to-production)\n* [stackoverflow-Node.js Production Deployment](http://stackoverflow.com/questions/15971156/node-js-production-deployment)\n* [stackoverflow-Deploying a production Node.js server](http://stackoverflow.com/questions/8386455/deploying-a-production-node-js-server)\n* [DEPLOYING NODE.JS TO PRODUCTION](http://codeplease.wordpress.com/2013/09/27/deploying-node-js-production/)\n* [HARDENING NODE.JS FOR PRODUCTION: A PROCESS SUPERVISOR](http://blog.argteam.com/coding/hardening-nodejs-production-process-supervisor/)\n* [book-How to Deploy a Node.js App to Production](http://fluentconf.com/fluent2012/public/schedule/detail/24643)\n* [Joyent-Production Practices-deploy](http://www.joyent.com/developers/node/deploy)\n* [Node.js deployment in production settings](http://ngo-hung.com/blog/2012/07/14/node-js-deployment-in-production-settings)\n* [Setup node.js Servers Within a Load-balanced Configuration](http://shawn.dahlen.me/blog/2013/03/18/setup-node-dot-js-servers-within-a-load-balanced-configuration/)\n* [Nodejs Production Deployment](http://cthayer.wordpress.com/2013/11/05/nodejs-production-deployment/)\n* [https://node.ci](https://node.ci/)","slug":"application_deploy","published":1,"updated":"2015-10-12T04:33:07.000Z","_id":"cifmere25001tvs1m6pnox43r","comments":1,"layout":"post","photos":[],"link":""},{"title":"About N","date":"2013-09-11T13:51:34.000Z","_content":"\nN即[Node.js](http://nodejs.org)\n\nN是一个关于Node.js的博客, 这里所有的一切都是关于Node.js.\n\n之前没写过博客, 最近想把自己学习到的东西总结一下分享出来, 于是... \n\n毕业后一直从事开发工作, 之前做Ruby On Rails和前端JS开发, 换工作后做Node.js. \n一接触就深深喜欢上了Node.js...\n\nNodejs是一个新技术, 虽然还不成熟, 但正在飞速成长和发展, 希望这里的分享能帮助大家更多了解Node.js, 促进Node.js的使用和发展.\n\nN的博客将会介绍内容:\n\n* N内部实现, 原理, 机制, 更新\n* N原生模块介绍\n* 优秀的N第三方模块\n* N在不同技术领域的应用\n* N的商业化进程\n\nN相关内容但本博客不会涉及: \n\n* JavaScript语言(Node.js的开发语言为JS, 所以想成为Node.js高手必须熟悉JS的语言特性-不涉及Dom,及兼容性部分)\n* V8&libuv(这两者为Node.js的基础核心, 想要深层次理解Node.js或进行Addon开发, 或参与Node.js源码开发这两者必须熟悉)\n\n\nN使用[hexo](http://zespia.tw/hexo/)搭建, 文章使用[Markdown](http://daringfireball.net/projects/markdown/)编辑.\n\nMy name is [Pana Wang](mailto:pana.wang@outlook.com)\n\n\n","source":"_posts/about.md","raw":"title:  About N\ndate: 2013-09-11 21:51:34\ntags: 说明\n---\n\nN即[Node.js](http://nodejs.org)\n\nN是一个关于Node.js的博客, 这里所有的一切都是关于Node.js.\n\n之前没写过博客, 最近想把自己学习到的东西总结一下分享出来, 于是... \n\n毕业后一直从事开发工作, 之前做Ruby On Rails和前端JS开发, 换工作后做Node.js. \n一接触就深深喜欢上了Node.js...\n\nNodejs是一个新技术, 虽然还不成熟, 但正在飞速成长和发展, 希望这里的分享能帮助大家更多了解Node.js, 促进Node.js的使用和发展.\n\nN的博客将会介绍内容:\n\n* N内部实现, 原理, 机制, 更新\n* N原生模块介绍\n* 优秀的N第三方模块\n* N在不同技术领域的应用\n* N的商业化进程\n\nN相关内容但本博客不会涉及: \n\n* JavaScript语言(Node.js的开发语言为JS, 所以想成为Node.js高手必须熟悉JS的语言特性-不涉及Dom,及兼容性部分)\n* V8&libuv(这两者为Node.js的基础核心, 想要深层次理解Node.js或进行Addon开发, 或参与Node.js源码开发这两者必须熟悉)\n\n\nN使用[hexo](http://zespia.tw/hexo/)搭建, 文章使用[Markdown](http://daringfireball.net/projects/markdown/)编辑.\n\nMy name is [Pana Wang](mailto:pana.wang@outlook.com)\n\n\n","slug":"about","published":1,"updated":"2015-10-10T10:19:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifmere27001uvs1mlb8exdoa"},{"title":"Go Package","date":"2015-10-12T13:13:40.000Z","banner":"/assets/gophercomplex1.jpg","_content":"\nGo 相较于 C++ 的一大进步即为具有良好的包管理系统. 在任何一个成熟的语言系统中包系统都是必不可少的. 本文将会对go的包系统进行详细的解释\n\n<!-- more -->\n\n### 定义\n\nGo 的包使用关键字 `package` 进行定义, 后跟包名\n\n```go\npackage main\n```\n\ngolang 的 package 和其他语言的组织方式完全不同, go 的 package 超越了文件的概念. 即多个文件可以有相同的 package name. 因此多个文件中不能出现相同的全局变量和函数，一个例外是init函数；而同一个package的不同文件可以直接引用相互之间的数据。\n\n包中的变量, 常量, 方法只有以大写字母作为首字符才算是外部可见内容, 否则只能在包内部使用.\n\n每个包文件都可以定义 init 方法, 用于包初始化操作\n\n```go\nfunc init () {\n\n}\n```\n\n一般情况下以代码文件所在的目录作为包名, 但并非强制. 同一个目录下至允许有一个包.\n\n### 特殊包 main\nmain 包在 go 中是一个特殊的包, 必须有且只有一个, 因为程序的入口函数(main)在该包中, main 函数没有参数, 没有返回\n\n```go\npackage main\n\nfunc main () {\n\n}\n```\n\n\n### 导入包\n包导入使用 import 关键字, 后跟字符串形式的包名. Go 的标准库可以直接以名字导入,其实是去GOROOT下去加载该模块\n\n```go\nimport \"fmt\"\n```\n\ngo的package是以绝对路径GOPATH来寻址的，不要用相对路径来import(虽然也支持).\n\n```go\nimport \"a/b/c\"     // 加载GOPATH/src/a/b/c\n```\n\n以通常惯例而言 import 路径的最后部分即为包名.\n\n多个包引入可以分成多行, 也可以一次导入\n\n```go\nimport (\n    \"fmt\"\n    \"log\"\n)\n```\n\n\n几个特殊用法\n\n```go\nimport _ “github.com/bitly/go-nsq” // 初始化某个包, 但不引入\nimport . \"fmt\"  // 调用包内容时可省略包名\nimport f \"fmt\"   // 别名导入\n```\n\ngo 语言认可两个特殊的代码包名称 all, std. 前者代表了 GOPATH 中包含的所有工作区的所有代码包, 后者代表了 Go 语言标准库中的所有代码包\n\n### 导入过程说明\n程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。下图详细地解释了整个执行过程\n\n![](/assets/go-package-import.jpg)\n\n通过上面的介绍我们了解了import的时候其实是执行了该包里面的init函数，初始化了里面的变量，_操作只是说该包引入了，只初始化里面的init函数和一些变量，不能通过包名来调用其它的函数，这有什么用呢？往往这些init函数里面是注册自己包里面的引擎，让外部可以方便的使用，就很多实现database/sql的引起，在init函数里面都是调用了sql.Register(name string, driver driver.Driver)注册自己，然后外部就可以使用了。\n\n\n### 工作区概念\n\ngo 是一门推崇软件工程理念的编程语言, 高度强调代码和项目的规范和统一. go 代码必须放在工作区中, 所谓的工作区就是一个特定的目录, 工作区中必须包含src, pkg, bin 三个目录.\n工作区路径需要被加入到 GOPATH 环境变量中.\n\n* src: 用于以代码包的形式组织, 保存源代码. 其中的代码包与src的子目录一一对应, 比如logging 包应位于logging目录下. main 包可以直接放在src下, 但通常不建议.\n* pkg: 用于存放由 go install 命令编译安装后的代码包, 通常以 .a 结尾\n* bin: 保存由 go install 命令完成之后生成的可执行文件\n\n工作区可以有多个(都加入到 GOPATH), 通过 go get 命令获取的代码位于 GOPATH 的第一个工作区中, 通常情况建议不要把 GOROOT 放到 GOPATH 中, 并且添加两个工作区\n到 GOPATH 中, 这样第一个工作区存放第三方库, 第二个则为真正的用户开发工作区.\n\n\n### 依赖管理\n在 Go 语言中，我们可以使用go get命令安装远程仓库中托管的代码，不同于 Ruby Gem、pypi 等集中式的包管理机制， Go 语言的包管理系统是去中心化的。简单来讲，go get命令支持任何一个位置托管的 Git 或 Mercurial 的仓库，无论是 Github 还是 Google Code 上的包，都可以通过这个命令安装\n\n虽然 Go 语言本身已经提供了相当强大的包管理方式了，但是仍然有一些不足：\n\n1. 不能很方便地隔离不同项目的环境\n2. 不能很方便地控制某个依赖包的版本\n3. 不能管理 Go 本身的版本\n\n关于这些问题的解决办法可参看[这里](http://io-meter.com/2014/07/30/go%27s-package-management/)\n\n\n\n### 参考\n\n* [godoc](http://godoc.org/)\n* [gopm.io](http://gopm.io/)\n* [Go 语言本身提供的包管理机制](http://io-meter.com/2014/07/30/go%27s-package-management/)\n","source":"_posts/go-package.md","raw":"title: Go Package\ndate: 2015-10-12 21:13:40\ntags:\nbanner: /assets/gophercomplex1.jpg\n---\n\nGo 相较于 C++ 的一大进步即为具有良好的包管理系统. 在任何一个成熟的语言系统中包系统都是必不可少的. 本文将会对go的包系统进行详细的解释\n\n<!-- more -->\n\n### 定义\n\nGo 的包使用关键字 `package` 进行定义, 后跟包名\n\n```go\npackage main\n```\n\ngolang 的 package 和其他语言的组织方式完全不同, go 的 package 超越了文件的概念. 即多个文件可以有相同的 package name. 因此多个文件中不能出现相同的全局变量和函数，一个例外是init函数；而同一个package的不同文件可以直接引用相互之间的数据。\n\n包中的变量, 常量, 方法只有以大写字母作为首字符才算是外部可见内容, 否则只能在包内部使用.\n\n每个包文件都可以定义 init 方法, 用于包初始化操作\n\n```go\nfunc init () {\n\n}\n```\n\n一般情况下以代码文件所在的目录作为包名, 但并非强制. 同一个目录下至允许有一个包.\n\n### 特殊包 main\nmain 包在 go 中是一个特殊的包, 必须有且只有一个, 因为程序的入口函数(main)在该包中, main 函数没有参数, 没有返回\n\n```go\npackage main\n\nfunc main () {\n\n}\n```\n\n\n### 导入包\n包导入使用 import 关键字, 后跟字符串形式的包名. Go 的标准库可以直接以名字导入,其实是去GOROOT下去加载该模块\n\n```go\nimport \"fmt\"\n```\n\ngo的package是以绝对路径GOPATH来寻址的，不要用相对路径来import(虽然也支持).\n\n```go\nimport \"a/b/c\"     // 加载GOPATH/src/a/b/c\n```\n\n以通常惯例而言 import 路径的最后部分即为包名.\n\n多个包引入可以分成多行, 也可以一次导入\n\n```go\nimport (\n    \"fmt\"\n    \"log\"\n)\n```\n\n\n几个特殊用法\n\n```go\nimport _ “github.com/bitly/go-nsq” // 初始化某个包, 但不引入\nimport . \"fmt\"  // 调用包内容时可省略包名\nimport f \"fmt\"   // 别名导入\n```\n\ngo 语言认可两个特殊的代码包名称 all, std. 前者代表了 GOPATH 中包含的所有工作区的所有代码包, 后者代表了 Go 语言标准库中的所有代码包\n\n### 导入过程说明\n程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。下图详细地解释了整个执行过程\n\n![](/assets/go-package-import.jpg)\n\n通过上面的介绍我们了解了import的时候其实是执行了该包里面的init函数，初始化了里面的变量，_操作只是说该包引入了，只初始化里面的init函数和一些变量，不能通过包名来调用其它的函数，这有什么用呢？往往这些init函数里面是注册自己包里面的引擎，让外部可以方便的使用，就很多实现database/sql的引起，在init函数里面都是调用了sql.Register(name string, driver driver.Driver)注册自己，然后外部就可以使用了。\n\n\n### 工作区概念\n\ngo 是一门推崇软件工程理念的编程语言, 高度强调代码和项目的规范和统一. go 代码必须放在工作区中, 所谓的工作区就是一个特定的目录, 工作区中必须包含src, pkg, bin 三个目录.\n工作区路径需要被加入到 GOPATH 环境变量中.\n\n* src: 用于以代码包的形式组织, 保存源代码. 其中的代码包与src的子目录一一对应, 比如logging 包应位于logging目录下. main 包可以直接放在src下, 但通常不建议.\n* pkg: 用于存放由 go install 命令编译安装后的代码包, 通常以 .a 结尾\n* bin: 保存由 go install 命令完成之后生成的可执行文件\n\n工作区可以有多个(都加入到 GOPATH), 通过 go get 命令获取的代码位于 GOPATH 的第一个工作区中, 通常情况建议不要把 GOROOT 放到 GOPATH 中, 并且添加两个工作区\n到 GOPATH 中, 这样第一个工作区存放第三方库, 第二个则为真正的用户开发工作区.\n\n\n### 依赖管理\n在 Go 语言中，我们可以使用go get命令安装远程仓库中托管的代码，不同于 Ruby Gem、pypi 等集中式的包管理机制， Go 语言的包管理系统是去中心化的。简单来讲，go get命令支持任何一个位置托管的 Git 或 Mercurial 的仓库，无论是 Github 还是 Google Code 上的包，都可以通过这个命令安装\n\n虽然 Go 语言本身已经提供了相当强大的包管理方式了，但是仍然有一些不足：\n\n1. 不能很方便地隔离不同项目的环境\n2. 不能很方便地控制某个依赖包的版本\n3. 不能管理 Go 本身的版本\n\n关于这些问题的解决办法可参看[这里](http://io-meter.com/2014/07/30/go%27s-package-management/)\n\n\n\n### 参考\n\n* [godoc](http://godoc.org/)\n* [gopm.io](http://gopm.io/)\n* [Go 语言本身提供的包管理机制](http://io-meter.com/2014/07/30/go%27s-package-management/)\n","slug":"go-package","published":1,"updated":"2015-10-18T01:42:36.000Z","_id":"cifnz84vb00032m1m9ag0z7tv","comments":1,"layout":"post","photos":[],"link":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cifmere020006vs1mg6mqi0cn","tag_id":"cifmere030007vs1mstnaqwsd","_id":"cifmere040008vs1mvjrlxvhn"},{"post_id":"cifmere08000avs1mkx29h61e","tag_id":"cifmere09000bvs1m30xfgx1w","_id":"cifmere09000cvs1m1lwee69p"},{"post_id":"cifmere0d000evs1mp42rkia1","tag_id":"cifmere0e000fvs1m3gt0ew10","_id":"cifmere0f000gvs1m1m17ay0w"},{"post_id":"cifmere0h000hvs1mp4ju5vct","tag_id":"cifmere0i000ivs1mctun3poj","_id":"cifmere0i000jvs1mvr1q088x"},{"post_id":"cifmere0k000kvs1myry81k7b","tag_id":"cifmere0l000lvs1m58dhhp09","_id":"cifmere0n000mvs1m2puneq48"},{"post_id":"cifmere0s000pvs1m9eubwijq","tag_id":"cifmere0u000qvs1mqi5ebh4g","_id":"cifmere0u000rvs1mdi4jzkyr"},{"post_id":"cifmere0v000svs1mqmyp7181","tag_id":"cifmere0x000tvs1msdsd0qqo","_id":"cifmere0y000uvs1m6941nfco"},{"post_id":"cifmere12000wvs1m1ya9zaip","tag_id":"cifmere13000xvs1me208ntvp","_id":"cifmere13000yvs1mwvgihwaq"},{"post_id":"cifmere14000zvs1mj253k688","tag_id":"cifmere150010vs1m8961bl23","_id":"cifmere160011vs1mzevp9j08"},{"post_id":"cifmere170012vs1m5nkj473o","tag_id":"cifmere180013vs1mxg8vhs7b","_id":"cifmere180014vs1ml1xzi77n"},{"post_id":"cifmere190015vs1mawtp1ja6","tag_id":"cifmere1b0016vs1m165aa7vs","_id":"cifmere1c0017vs1mzop9pmft"},{"post_id":"cifmere1g0019vs1mfh2kvfxh","tag_id":"cifmere1h001avs1mhbgmtkhq","_id":"cifmere1i001bvs1mcl8qlx1c"},{"post_id":"cifmere1j001cvs1my4u1ljpz","tag_id":"cifmere1k001dvs1myjuvomab","_id":"cifmere1k001evs1m4wop2o5d"},{"post_id":"cifmere1l001fvs1mng4umc9i","tag_id":"cifmere180013vs1mxg8vhs7b","_id":"cifmere1m001gvs1mvc3c5sq1"},{"post_id":"cifmere1p001ivs1mwmw00nj2","tag_id":"cifmere1q001jvs1md1j03032","_id":"cifmere1q001kvs1mlwj7zw41"},{"post_id":"cifmere1w001nvs1ma0kebly0","tag_id":"cifmere1y001ovs1mdl3398u1","_id":"cifmere1y001pvs1mb000zqmm"},{"post_id":"cifmere1z001qvs1mog3m1879","tag_id":"cifmere23001rvs1m2k1red86","_id":"cifmere23001svs1moe8c0cst"},{"post_id":"cifmere27001uvs1mlb8exdoa","tag_id":"cifmere2b001vvs1muy6akan4","_id":"cifmere2b001wvs1my26zzugr"}],"Tag":[{"name":"更新","_id":"cifmerdzv0003vs1m5m5ehm6e"},{"name":"应用","_id":"cifmere030007vs1mstnaqwsd"},{"name":"REPL","_id":"cifmere09000bvs1m30xfgx1w"},{"name":"安装","_id":"cifmere0e000fvs1m3gt0ew10"},{"name":"Intro","_id":"cifmere0i000ivs1mctun3poj"},{"name":"Native Module","_id":"cifmere0l000lvs1m58dhhp09"},{"name":"应用场景","_id":"cifmere0u000qvs1mqi5ebh4g"},{"name":"conference","_id":"cifmere0x000tvs1msdsd0qqo"},{"name":"Competition","_id":"cifmere13000xvs1me208ntvp"},{"name":"blog&cms","_id":"cifmere150010vs1m8961bl23"},{"name":"Module","_id":"cifmere180013vs1mxg8vhs7b"},{"name":"HelloWorld","_id":"cifmere1b0016vs1m165aa7vs"},{"name":"ES6 异步流程","_id":"cifmere1h001avs1mhbgmtkhq"},{"name":"Express upgrade","_id":"cifmere1k001dvs1myjuvomab"},{"name":"工具","_id":"cifmere1q001jvs1md1j03032"},{"name":"coffeescript","_id":"cifmere1y001ovs1mdl3398u1"},{"name":"国内","_id":"cifmere23001rvs1m2k1red86"},{"name":"说明","_id":"cifmere2b001vvs1muy6akan4"}]}}